<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. 引言 &mdash; 基于loongarch64的一个小型操作系统实验（改编自北航mos操作系统） V1.0 文档</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=b01b2dd9" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=9c3e77be" />
      <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=3f0bcac8"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="_static/copybutton.js?v=f281be69"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="_static/togglebutton.js?v=1ae7504c"></script>
        <script src="_static/translations.js?v=beaddf03"></script>
        <script src="_static/design-tabs.js?v=f930bc37"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="prev" title="目录" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <img src="_static/logo.svg" class="logo" alt="Logo"/>
          <a href="index.html" class="icon icon-home">
            基于loongarch64的一个小型操作系统实验（改编自北航mos操作系统）
          </a>
              <div class="version">
                V1.0
              </div>
<div role="search">
  <form id="evas-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. 引言</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">1.1. 引言</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">1.2. 实验内容</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">1.3. 实验设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1.4. 实验环境配置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">1.4.1. 虚拟机平台以及镜像</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">1.4.2. 交叉编译器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loongarch64">1.4.3. loongarch64仿真器</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#printf">2. 实验一：内核、启动和printf</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id8">2.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">2.2. 操作系统的启动</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">2.2.1. 硬件模拟器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">2.2.2. 硬件模拟器的启动流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id12">2.3. 内核，启动！</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#makefile">2.3.1. Makefile—内核代码的地图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elf">2.3.2. ELF—操作系统内核的本质</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linkerscript">2.3.3. LinkerScript—控制内核加载地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="#start">2.3.4. _start—程序执行的第一条指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#printk">2.4. 实战printk</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id13">2.5. 实验一正确结果</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id14">3. 实验二：内存管理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id15">3.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">3.2. loongarch64的访存流程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpu">3.2.1. CPU发出地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">3.2.2. 虚拟地址映射到物理地址</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id18">3.3. 内核程序启动</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#la32r-detect-memory">3.3.1. la32r_detect_memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#la32r-vm-init">3.3.2. la32r_vm_init</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id19">3.4. 物理内存管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id20">3.4.1. 链表宏</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">3.4.2. 页控制块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">3.4.3. 其他相关函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id23">3.4.4. 实验结果展示</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id24">3.5. 虚拟内存管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id25">3.5.1. 二级页表结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id26">3.5.2. 与页表相关的函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tlb">3.6. 访问内存与TLB重填</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id27">3.6.1. TLB相关的前置知识</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">3.6.2. TLB维护流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id29">3.7. 实验正确结果</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id30">3.7.1. 实验代码功能解释</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">3.7.2. 正确实验结果展示</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id32">4. 实验三：进程与异常</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id33">4.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id34">4.2. 进程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id35">4.2.1. 进程控制块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id36">4.2.2. 段地址映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id37">4.2.3. 进程的标识</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id38">4.2.4. 设置进程控制块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id39">4.2.5. 加载二进制镜像</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id40">4.2.6. 创建进程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id41">4.2.7. 进程运行与切换</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">4.2.8. 实验正确结果</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id43">4.3. 中断与例外</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id44">4.3.1. 例外的分发</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">4.3.2. 例外向量组</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id46">4.3.3. 时钟中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id47">4.3.4. 进程调度</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id48">4.4. 代码导读</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id49">4.5. 实验正确结果</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#fork">5. 实验四：系统调用与FORK</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id50">5.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#system-call">5.2. 系统调用(System Call)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id51">5.2.1. 用户态与内核态</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id52">5.2.2. 系统调用实例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id53">5.2.3. 系统调用机制的实现</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id54">5.2.4. 基础系统调用函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ipc">5.3. 进程间通信机制(IPC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id55">5.4. Fork</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id56">5.4.1. 初窥 fork</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id57">5.4.2. 写时复制机制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id58">5.4.3. fork 的返回值</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id59">5.4.4. 地址空间的准备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id60">5.4.5. 页写入异常</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id61">5.5. 实验正确结果</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id62">6. 实验五：文件系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id63">6.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id64">6.2. 文件系统概述</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id65">6.2.1. 文件系统的设计与实现</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ide">6.3. IDE 磁盘驱动</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#i-o-mmio">6.3.1. 内存映射 I/O (MMIO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id66">6.3.2. IDE 磁盘</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id67">6.3.3. 驱动程序编写</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id68">6.4. 文件系统结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id69">6.4.1. 磁盘文件系统布局</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id70">6.4.2. 文件系统详细结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id71">6.4.3. 块缓存</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id72">6.5. 文件系统的用户接口</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id73">6.5.1. 文件描述符</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id74">6.5.2. 文件系统服务</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id75">6.6. 实验结果展示</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id76">6.6.1. IDE 磁盘交互</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id77">6.6.2. 文件系统测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id78">6.6.3. 文件系统服务测试</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#shell">7. 实验六：管道与 SHELL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id79">7.1. 实验目的</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id80">7.2. 管道</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id81">7.2.1. 初窥管道</a></li>
<li class="toctree-l3"><a class="reference internal" href="#la64-pipe">7.2.2. la64 中 pipe 的使用与实现</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id82">7.2.3. 管道关闭的正确判断</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id83">7.2.4. 相关函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id84">7.3. shell</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#spawn">7.3.1. 学习 spawn 函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id85">7.3.2. 解释 shell 命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id86">7.3.3. 相关函数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id87">7.4. 实验正确结果</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id88">7.4.1. 管道测试</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id89">7.4.2. shell 测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">基于loongarch64的一个小型操作系统实验（改编自北航mos操作系统）</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">1. </span>引言</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1><span class="section-number">1. </span>引言<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<section id="id2">
<h2><span class="section-number">1.1. </span>引言<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>本实验根据北航操作系统课程上提供的教学型小型操作系统mos改编而来。mos目前提供有mips和la32r两种架构的版本，经过详细分析代码和构建，发现la32r有着诸多不足之处，基本是mips架构的重编版本。于是为了学习loongarch架构和供后来者参考，在复现原本实验内容的前提下，将la32r版本改写为la64的版本，其中有些函数名字中的la32r未进行更改，但内容已经更新为la64架构，新版本充分体现了loongarch64特点。</p>
</section>
<section id="id3">
<h2><span class="section-number">1.2. </span>实验内容<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<p>实验内容与原本mos完成的实验内容相同，分为6个实验（Lab1~Lab6），各个实验的相互关系如图1所示，具体实验内容如下：</p>
<ol class="arabic simple">
<li><p>内核、启动和 printf ：通过 PC 启动的实验，掌握硬件的启动过程，理解链接地址、加载地址和重定位的概念，学习如何编写裸机代码。</p></li>
<li><p>进程与异常：通过设置进程控制块和编写进程创建、进程中止和进程调度程序，实现进程管理；编写通用中断分派程序和时钟中断例程，实现中断管理。</p></li>
<li><p>系统调用与fork：掌握系统调用的实现方法，理解系统调用的处理流程，实现本实验所需的系统调用。</p></li>
<li><p>文件系统：通过实现一个简单的、基于磁盘的、微内核方式的文件系统，掌握文件系统的实现方法和层次结构。</p></li>
<li><p>管道与shell：实现具有管道，重定向功能的命令解释程序shell，能够执行一些简单的命令。最后将6部分链接起来，使之成为一个能够运行的操作系统。</p></li>
</ol>
<img alt="实验内容关系图" class="bg-primary align-center" src="_images/%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E8%81%94%E7%B3%BB.png" />
</section>
<section id="id4">
<h2><span class="section-number">1.3. </span>实验设计<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<p>由于开发一个实际的操作系统难度大、工作量繁重，为了保证教学效果，在核心能力部分采用微内核结构和增量式设计的原则，因此可以从最基本的硬件管理功能逐步扩充，最后完成一个完整的系统。实验内容的设计满足以下条件：</p>
<ol class="arabic simple">
<li><p>每个实验可独立运行与测试，便于调试与评测，可获得阶段性成果。</p></li>
<li><p>每个实验内容包含相对独立的知识点，并只依赖其前序实验。</p></li>
<li><p>各个实验提交的代码一直伴随整个实验过程，可以不断改进、完善代码。<br />
整个系统结构如图2所示，蓝色部分是每次实验需要新增加的模块，绿色部分是需要修改完善的模块，灰色部分是不用修改的模块。在增量式设计下，可以从基本的功能出发，逐步完善整个系统，从而降低了学习操作系统的难度。</p></li>
</ol>
<p>为了适应不同读者的学习要求，本书的实验采用分层的方式，从基础到复杂逐步实现实验的基本目标。因此，可将实验基本目标分为三个层次：</p>
<ul class="simple">
<li><p>第一层次，掌握基本的系统使用与编程能力：包括 Linux、Makefile、git、vim 和仿真器的使用，基本的 shell 编程和使用系统调用编程;</p></li>
<li><p>第二层次，掌握操作系统核心能力：包括6个实验，从操作系统内核构造、内存管理、进程管理、系统调用、文件系统和命令解释程序，构成一个完整的小型操作系 统;</p></li>
<li><p>第三层次，锻炼操作系统提升能力：主要包括若干挑战性任务，学生需要独立在某一方面实现若干新的系统功能。</p></li>
</ul>
</section>
<section id="id5">
<h2><span class="section-number">1.4. </span>实验环境配置<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<p>所有实验须在linux系统上运行，因此需要搭建虚拟机平台，包含实验需要的开发环境，例如Linux环境、交叉编译器、loongarch64仿真器等。</p>
<section id="id6">
<h3><span class="section-number">1.4.1. </span>虚拟机平台以及镜像<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>虚拟机平台使用VMware Workstation Pro，镜像使用的是ubuntu22.04，二者均可到官网下载，这里不再赘述安装过程。</p>
</section>
<section id="id7">
<h3><span class="section-number">1.4.2. </span>交叉编译器<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>运行la64所需要的交叉编译器为<code class="docutils literal notranslate"><span class="pre">loongarch64-unknown-linux-gnu-</span></code>，可使用以下命令进行安装</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>wget<span class="w"> </span>https://github.com/loongson/build-tools/releases/download/2023.08.08/x86_64-cross-tools-loongarch64-gcc-libc.tar.xz
tar<span class="w"> </span>xvf<span class="w"> </span>./x86_64-cross-tools-loongarch64-gcc-libc.tar.xz
</pre></div>
</div>
<p>解压完成后使用<code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">vim</span> <span class="pre">/etc/profile</span></code>指令进入配置文件，在文件末尾添加如下两行代码：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>loongarch64-unknown-linux-gnu-
<span class="nb">export</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span>/path/of/your/cross/compile/cross-tools/bin:<span class="nv">$PATH</span>
</pre></div>
</div>
<p>保存退出后，重启虚拟机或使用如下指令重新应用配置文件：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span><span class="w"> </span>/etc/profile
</pre></div>
</div>
<p>重启系统后，使用以下命令检查软件安装情况：</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>loongarch64-unknown-linux-gnu-gcc<span class="w"> </span>--version
<span class="c1">#出现以下版本信息则说明交叉编译器安装完成  </span>
loongarch64-unknown-linux-gnu-gcc<span class="w"> </span><span class="o">(</span>GCC<span class="o">)</span><span class="w"> </span><span class="m">14</span>.0.0<span class="w"> </span><span class="m">20231018</span><span class="w"> </span><span class="o">(</span>experimental<span class="o">)</span><span class="w">  </span>
Copyright<span class="w"> </span><span class="o">(</span>C<span class="o">)</span><span class="w"> </span><span class="m">2023</span><span class="w"> </span>Free<span class="w"> </span>Software<span class="w"> </span>Foundation,<span class="w"> </span>Inc.<span class="w">  </span>
This<span class="w"> </span>is<span class="w"> </span>free<span class="w"> </span>software<span class="p">;</span><span class="w"> </span>see<span class="w"> </span>the<span class="w"> </span><span class="nb">source</span><span class="w"> </span><span class="k">for</span><span class="w"> </span>copying<span class="w"> </span>conditions.<span class="w">  </span>There<span class="w"> </span>is<span class="w"> </span>NO<span class="w">  </span>
warranty<span class="p">;</span><span class="w"> </span>not<span class="w"> </span>even<span class="w"> </span><span class="k">for</span><span class="w"> </span>MERCHANTABILITY<span class="w"> </span>or<span class="w"> </span>FITNESS<span class="w"> </span>FOR<span class="w"> </span>A<span class="w"> </span>PARTICULAR<span class="w"> </span>PURPOSE.<span class="w">  </span>
</pre></div>
</div>
</section>
<section id="loongarch64">
<h3><span class="section-number">1.4.3. </span>loongarch64仿真器<a class="headerlink" href="#loongarch64" title="Link to this heading"></a></h3>
<p>实验中使用的硬件模拟器是QEMU，下面介绍如何进行安装<br />
下载QEMU源码包</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>wget<span class="w"> </span>https://download.qemu.org/qemu-9.0.2.tar.xz<span class="w">  </span>
</pre></div>
</div>
<p>解压</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>tar<span class="w"> </span>-xvf<span class="w"> </span>qemu-9.0.2.tar.xz<span class="w">  </span>
</pre></div>
</div>
<p>编译</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>qemu-9.0.2<span class="w">  </span>
$<span class="w"> </span>../configure<span class="w"> </span><span class="se">\ </span><span class="w"> </span>
<span class="w">  </span>--target-list<span class="o">=</span>loongarch64-softmmu<span class="w"> </span><span class="se">\ </span><span class="w"> </span>
<span class="w">  </span>--enable-slirp<span class="w">  </span>
$<span class="w"> </span>make<span class="w"> </span>-j24<span class="w">  </span>
</pre></div>
</div>
<p>完成后进行路径添加，使用<code class="docutils literal notranslate"><span class="pre">vim</span> <span class="pre">~/.bashrc</span></code>指令进入配置文件，在文件末尾添加如下代码：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span>/your/qemu/path/qemu-9.2.0/build:<span class="nv">$PATH</span><span class="w">  </span>
</pre></div>
</div>
<p>保存退出后，重启虚拟机或使用如下指令重新应用配置文件：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span><span class="w"> </span>~/.bashrc
</pre></div>
</div>
<p>重启系统后，使用以下命令检查QEMU安装情况：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>qemu-system-loongarch64<span class="w"> </span>-M<span class="w"> </span>?<span class="w">  </span>
<span class="c1">#出现以下信息则说明qemu安装成功  </span>
Supported<span class="w"> </span>machines<span class="w"> </span>are:<span class="w">  </span>
none<span class="w">                 </span>empty<span class="w"> </span>machine<span class="w">  </span>
virt<span class="w">                 </span>QEMU<span class="w"> </span>LoongArch<span class="w"> </span>Virtual<span class="w"> </span>Machine<span class="w"> </span><span class="o">(</span>default<span class="o">)</span><span class="w">  </span>
</pre></div>
</div>
<p>搭建好环境后，即可开始进行我们的实验。</p>
</section>
</section>
</section>
<section id="printf">
<h1><span class="section-number">2. </span>实验一：内核、启动和printf<a class="headerlink" href="#printf" title="Link to this heading"></a></h1>
<section id="id8">
<h2><span class="section-number">2.1. </span>实验目的<a class="headerlink" href="#id8" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>从操作系统角度理解la64体系结构</p></li>
<li><p>掌握操作系统启动的基本流程</p></li>
<li><p>掌握 ELF 文件的结构和功能</p></li>
<li><p>理解 printk 函数的原理</p></li>
</ol>
</section>
<section id="id9">
<h2><span class="section-number">2.2. </span>操作系统的启动<a class="headerlink" href="#id9" title="Link to this heading"></a></h2>
<section id="id10">
<h3><span class="section-number">2.2.1. </span>硬件模拟器<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>计算机是由硬件和软件组成，如果仅有一个裸机什么工作也无法完成。另一方面，软件也必须运行在硬件之上才能实现其价值。由此可见，硬件和软件是相互依存、密不可分的。<br />
为了能较好的管理计算机系统的硬件资源，需要使用操作系统。那么在我们的操作系统实验中，需要管理的硬件在哪里呢？为了减少学习成本以及减少硬件不稳定带来的麻烦，在所有实验中使用 QEMU 硬件模拟器，模拟器可以模拟 CPU 等硬件环境。总的来说，在操作系统课程实验中，编写代码的环境是 Linux 系统，进行实验的硬件仿真平台是 QEMU 模拟器。实验编写的操作系统代码在 Linux 环境中通过 Makefile 来组织，通过交叉编译产生可执行文件，最后使用 QEMU 模拟器运行该可执行文件，实现 la64 操作系统的运行。</p>
</section>
<section id="id11">
<h3><span class="section-number">2.2.2. </span>硬件模拟器的启动流程<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>有过操作系统基础知识的同学应该都知道，操作系统的启动是一个非常复杂的过程，需要经过 bootloader 引导才可以真正开始运行。不过，由于本次实验的 la64 操作系统的目标是在模拟器上运行，这个过程被大大简化了。模拟器支持直接加载 ELF格式的内核，也就是说，模拟器已经提供了 bootloader 的引导（启动）功能。la64 操作系统不需要再实现 bootloader 的功能。在 la64 操作系统的运行第一行代码前，我们就已经拥有一个正常的程序运行环境，内存和一些外围设备都可以正常使用。模拟器支持加载 ELF 格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口，启动就完成了。这里要注意，之所以简单还有一个原因就在于QEMU本身是模拟器，是一种模拟硬件的软件而不是真正的硬件，所以就不需要面对传统的bootloader面对的那种非常纠结的情况了。</p>
</section>
</section>
<section id="id12">
<h2><span class="section-number">2.3. </span>内核，启动！<a class="headerlink" href="#id12" title="Link to this heading"></a></h2>
<p>接下来，我们就开始我们的la64操作系统内核的学习了。这一节中，我们将介绍如何修改内核并实现一些自定义的功能。</p>
<section id="makefile">
<h3><span class="section-number">2.3.1. </span>Makefile—内核代码的地图<a class="headerlink" href="#makefile" title="Link to this heading"></a></h3>
<p>当我们使用 ls 命令看看都有哪些实验代码时，会发现似乎文件目录有点多，各个不同的目录名称大致说明了他们各自的功用，但是挨个文件进行浏览还是有点难度。此时我们就可以进入到一个文件，叫做 Makefile。 相信有过操作系统学习的同学已经对 Makefile 有了初步的了解。下面这个 Makefile 文件即为构建我们整个操作系统所用的顶层 Makefil e。那么，我们就可以通过浏览这个文件来对整个操作系统的布局产生初步的了解：可以说，Makefile 就像源代码的地图，告诉我们源代码是如何一步一步成为最终的可执行文件的。以下代码是实验代码最顶层的 Makefile 节选，通过阅读它我们就能了解代码中很多宏观的东西。</p>
<div class="highlight-Makefile notranslate"><div class="highlight"><pre><span></span><span class="cp">include include.mk  </span>
<span class="w">  </span>
<span class="nv">lab</span><span class="w">                     </span><span class="o">?=</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span>cat<span class="w"> </span>.mos-this-lab<span class="w"> </span><span class="m">2</span>&gt;/dev/null<span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="m">6</span><span class="k">)</span><span class="w">  </span>
<span class="w">  </span>
<span class="nv">target_dir</span><span class="w">              </span><span class="o">:=</span><span class="w"> </span>target<span class="w">                   </span><span class="c1"># la64 构建目标所在目录  </span>
<span class="nv">mos_elf</span><span class="w">                 </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>target_dir<span class="k">)</span>/mos<span class="w">        </span><span class="c1"># 最终需要生成的ELF可执行文件  </span>
<span class="nv">user_disk</span><span class="w">               </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>target_dir<span class="k">)</span>/fs.img<span class="w">     </span><span class="c1"># la64 文件系统使用的磁盘镜像文件  </span>
<span class="nv">qemu_pts</span><span class="w">                </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>shell<span class="w"> </span><span class="o">[</span><span class="w"> </span>-f<span class="w"> </span>.qemu_log<span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>grep<span class="w"> </span>-Eo<span class="w"> </span><span class="s1">&#39;/dev/pts/[0-9]+&#39;</span><span class="w"> </span>.qemu_log<span class="k">)</span><span class="w">  </span>
<span class="nv">link_script</span><span class="w">             </span><span class="o">:=</span><span class="w"> </span>kernel.lds<span class="w">  </span>
<span class="w">  </span>
<span class="nv">modules</span><span class="w">                 </span><span class="o">:=</span><span class="w"> </span>lib<span class="w"> </span>init<span class="w"> </span>kern<span class="w">            </span><span class="c1"># 需要生成的子模块  </span>
<span class="nv">targets</span><span class="w">                 </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>mos_elf<span class="k">)</span><span class="w">  </span>
<span class="nv">syms_file</span><span class="w">               </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>target_dir<span class="k">)</span>/prog.syms<span class="w">  </span>
<span class="nv">qemu_files</span><span class="w">              </span><span class="o">:=</span><span class="w"> </span><span class="k">$(</span>mos_elf<span class="k">)</span><span class="w">  </span>
<span class="w">  </span>
<span class="nv">QEMU_FLAGS</span><span class="w">              </span><span class="o">:=</span><span class="w"> </span>-M<span class="w"> </span>virt<span class="w"> </span>-m<span class="w"> </span>4G<span class="w"> </span>-d<span class="w"> </span>in_asm,mmu<span class="w"> </span>-D<span class="w"> </span>debug.log<span class="w"> </span>-nographic<span class="w"> </span><span class="se">\ </span><span class="w"> </span>
</pre></div>
</div>
<p>完整的 Makefile 文件内容在这里不做过多解释，请读者自行阅读理解。需要关注的是第16行的 QEMU_FLAGS 参数 -d 和 -D ，-d 表示选择调试内容类型，in_asm 代表输出 CPU 执行的每一条指令（反汇编），mmu 代表 MMU 地址转换，也就是 TLB 行为，-D 表示调试输出位置，二者经常搭配使用。比如在以上 Makefile 文件中，二者使用表示将 QEMU 中 CPU 执行的每一条反汇编指令以及涉及到的 TLB 行为输出到 Makefile 所在目录下的 debug.log 文件中，通过查看该日志即可观察 QEMU 的执行信息，经常用于调试。</p>
</section>
<section id="elf">
<h3><span class="section-number">2.3.2. </span>ELF—操作系统内核的本质<a class="headerlink" href="#elf" title="Link to this heading"></a></h3>
<p>通过阅读 Makefile 文件，我们大致把握了 la64 操作系统的代码组织结构。在这一小节里，我们来进一步探究 la64 代码最终编译链接得到“操作系统内核”究竟是什么。<br />
我们知道源代码文件需要经过编译和链接两个阶段，才能变成完整的可执行文件来运行。在编译阶段，每个源文件被翻译成二进制指令，得到目标文件，也就是我们通过-c编译选项生成的.o 文件。然而，由于完整程序的地址布局尚未确定，目标文件中的跳转等指令中的目标地址还是空的。在链接阶段，链接器会将所有的目标文件链接在一起，并填写具体的地址等信息，形成最终的可执行文件。<br />
接下来，我们提出我们的下一个问题：链接器通过哪些信息来链接多个目标文件呢？答案就在于在目标文件的结构中。在目标文件中，记录了代码各个段的具体信息。链接器通过这些信息 来将目标文件链接到一起。而 ELF(Executable and Linkable Format) 正是 Unix 上常用的一种目标文件格式。其实，不仅仅是目标文件，可执行文件也是使用ELF格式记录的。这一点通过 ELF 的全称也可以看出来。<br />
我们前面编译出来的la64内核本质上也是一个ELF文件。为了进一步了解编译出的内核文件，我们需要进一步探究ELF文件的功能以及格式。 ELF 是一种用于可执行文件、目标文件和库的文件格式。ELF格式是是 UNIX 系统实验室作为ABI(Application Binary Interface) 而开发和发布的，现在早已经是 Linux 下的标准格式了。我们在之前曾经看见过的.o文件就是ELF所包含的三种文件类型中的一种，称为可重定位 (relocatable) 文件，其它两种文件类型分别是可执行 (executable) 文件和共享对象 (shared object) 文件，这两种文件都需要链接器对可重定位文件进行处理才能生成。<br />
那么，ELF 文件中都包含有什么东西呢？简而言之，就是和程序相关的所有必要信息。下面我们可能进行一个小练习来观察ELF文件的结构。<br />
阅读 tools/readelf 目录下的 elf.h、readelf.c 和 main.c 文件，同时可以进入根目录下的 /usr/include/elf.h 文件进行阅读，这是 ubuntu 镜像所使用的elf.h文件，将其与 la64 使用的 elf.h 进行对比，看看我们使用的微内核与真正的操作系统使用的有何不同。在 tools/readelf 目录下执行 <code class="docutils literal notranslate"><span class="pre">make</span></code> 命令，即可生成可执行文件 readelf，它接受文件名作为参数，对 ELF 文件进行解析。可以执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">hello</span></code> 生成测试用的ELF文件 hello，然后运行 <code class="docutils literal notranslate"><span class="pre">./readelf</span> <span class="pre">hello</span></code> 来测试 readelf。</p>
</section>
<section id="linkerscript">
<h3><span class="section-number">2.3.3. </span>LinkerScript—控制内核加载地址<a class="headerlink" href="#linkerscript" title="Link to this heading"></a></h3>
<p>生成内核文件之后，我们现在需要让内核被加载到正确的地址。之前在分析 ELF 文件时我们曾看到过，编译器在生成 ELF 文件时就已经记录了各节所需要被加载到的位置。同时，我们也发现，最终的可执行文件实际上是由链接器产生的（它将多个目标文件链接产生最终可执行文件）。因此，我们所需要做的，就是控制链接器的链接过程。<br />
接下来，我们就要引入一个神奇的东西：LinkerScript。链接器的设计者们在设计链接器的时候面临这样一个问题：不同平台的 ABI (ApplicationBinaryInterface) 都不一样，怎样做才能增加链接器的通用性，使得它能为各个不同的平台生成可执行文件呢？于是，就有了 Linker Script。LinkerScript 中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。使用命令 <code class="docutils literal notranslate"><span class="pre">ld</span> <span class="pre">--verbose</span></code> 可以输出默认的链接脚本，你可以在自己的机器上尝试这一条命令。<br />
因此，我们可以通过 LinkerScript 来尝试调整各节的位置。阅读 kernel.lds 文件，即可知道内核开始加载的位置。<br />
再补充一点：关于链接后的程序从何处开始执行。程序执行的第一条指令的地址称为入口地址（entrypoint）。我们的实验就在 kernel.lds 中通过 ENTRY(_start) 来设置程序入口为 _start。</p>
</section>
<section id="start">
<h3><span class="section-number">2.3.4. </span>_start—程序执行的第一条指令<a class="headerlink" href="#start" title="Link to this heading"></a></h3>
<p>下面为 init/start.S 文件中内容，来大致阅读并分析一下 _start 函数代码。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span>  <span class="c1">#include &lt;asm/asm.h&gt;</span>
<span class="mi">02</span>  <span class="c1">#include &lt;mmu.h&gt;</span>
 
<span class="mi">03</span>  <span class="o">.</span><span class="n">section</span> <span class="o">.</span><span class="n">text</span>
<span class="mi">04</span>  <span class="o">.</span><span class="k">global</span> <span class="n">_start</span>
<span class="mi">05</span>  <span class="n">_start</span><span class="p">:</span>
<span class="mi">06</span> 
<span class="mi">07</span>      <span class="o">/*</span> <span class="n">initialize</span> <span class="o">*/</span>
<span class="mi">08</span>      <span class="c1">#if !defined(LAB) || LAB &gt;= 3</span>
<span class="mi">09</span>      <span class="n">la</span>      <span class="n">a0</span><span class="p">,</span> <span class="n">exc_gen_entry</span>
<span class="mi">10</span>      <span class="n">csrwr</span>   <span class="n">a0</span><span class="p">,</span> <span class="n">csr_eentry</span>
<span class="mi">11</span>      <span class="c1">#endif</span>
<span class="mi">12</span>   
<span class="mi">13</span>      <span class="c1">#if !defined(LAB) || LAB &gt;= 2</span>
<span class="mi">14</span>      <span class="n">la</span>      <span class="n">a1</span><span class="p">,</span> <span class="n">tlb_miss_entry</span>
<span class="mi">15</span>      <span class="n">csrwr</span>   <span class="n">a1</span><span class="p">,</span> <span class="n">csr_tlbrentry</span>
<span class="mi">16</span>      <span class="c1">#endif</span>
<span class="mi">17</span>   
<span class="mi">18</span>      <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0x9000000000000001</span>
<span class="mi">19</span>      <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw0</span>
<span class="mi">20</span>   
<span class="mi">21</span>      <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0x0000000000000000</span>
<span class="mi">22</span>      <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw1</span>
<span class="mi">23</span>      <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw2</span>
<span class="mi">24</span>      <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw3</span>
<span class="mi">25</span>   
<span class="mi">26</span>      <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0xb0</span>
<span class="mi">27</span>      <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_crmd</span>
<span class="mi">28</span>       
<span class="mi">29</span>      <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0x0c000000</span>
<span class="mi">30</span>     <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_tlbidx</span>
<span class="mi">31</span>   
<span class="mi">32</span>      <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">t0</span><span class="p">,</span> <span class="n">ESTAT_TI</span>
<span class="mi">33</span>      <span class="n">csrwr</span>       <span class="n">t0</span><span class="p">,</span> <span class="n">csr_ectl</span>
<span class="mi">34</span>       
<span class="mi">35</span>      <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">sp</span><span class="p">,</span> <span class="n">KSTACKTOP</span>
<span class="mi">36</span>   
<span class="mi">37</span>      <span class="n">la</span><span class="o">.</span><span class="k">global</span>   <span class="n">t0</span><span class="p">,</span> <span class="o">.</span><span class="n">bss</span>
<span class="mi">38</span>      <span class="n">la</span><span class="o">.</span><span class="k">global</span>   <span class="n">t1</span><span class="p">,</span> <span class="n">bss_end</span>
<span class="mi">39</span>  <span class="n">bss_loop</span><span class="p">:</span>
<span class="mi">40</span>          <span class="n">beq</span>         <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">bss_loop_end</span>
<span class="mi">41</span>          <span class="n">st</span><span class="o">.</span><span class="n">b</span>        <span class="n">zero</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">0</span>
<span class="mi">42</span>          <span class="n">addi</span><span class="o">.</span><span class="n">d</span>      <span class="n">t0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">1</span>
<span class="mi">43</span>          <span class="n">b</span>           <span class="n">bss_loop</span>
<span class="mi">44</span>  <span class="n">bss_loop_end</span><span class="p">:</span>
<span class="mi">45</span>          <span class="n">b</span>           <span class="n">la32r_init</span>
<span class="mi">46</span>          <span class="n">nop</span>
</pre></div>
</div>
<p>阅读以上代码，10~11，15~16行，作用是将我们后面要用到的函数起始地址写入寄存器中，如果要执行函数则会通过该寄存器记录的地址去进行函数执行。19-36行则是将一些数值写入寄存器中，后面会有详细的解释。36行则是将 sp 寄存器设置到内核栈空间的位置上，随后跳转到 la32r_init 函数。内核栈空间的地址可以从include/mmu.h 中看到。 这里做一个提醒，请注意栈的增长方向。设置完栈指针后，我们就具备了执行C语言代码的条件，因此，接下来的工作就可以交给C代码来完成了。所以，在_start的最后，我们调用C代码的主函数，正式进入内核的C语言部分。其中 la32r_init 函数位于 init/init.c 中。</p>
</section>
</section>
<section id="printk">
<h2><span class="section-number">2.4. </span>实战printk<a class="headerlink" href="#printk" title="Link to this heading"></a></h2>
<p>了解了这么多的内容后，我们来进行一番实战，在内核中实现一个 printk 函数。在平时使用中，你可能觉得 printf 函数是由语言本身提供的，其实不是，printf 全都是由C语言的标准库提供的。而C语言的标准库是建立在操作系统基础之上的。所以，当我们开发操作系统的时候，我们就会发现，我们失去了C语言标准库的支持。我们需要用到的几乎所有东西，都需要我们自己来实现。<br />
要弄懂内核如何将信息输出到控制台，需要阅读以下三个文件：kern/printk.c，lib/print.c 和kern/machine.c。<br />
首先大家先对它们的大致的内容有个了解：</p>
<ol class="arabic simple">
<li><p>kern/machine.c:这个文件负责往 QEMU 的控制台输出字符，其原理为读写某一个特殊的内存地址。</p></li>
<li><p>kern/printk.c:此文件中，实现了printk，但其所做的，实际上是把输出字符的函数，接受的输出参数给传递给了 vprintfmt 这个函数。</p></li>
<li><p>lib/print.c:此文件中，实现了 vprintfmt 函数，其实现了格式化输出的主体逻辑。
接着为了便于理解，我们一起来梳理一下这几个文件之间的关系。<br />
kern/printk.c 中定义了我们的 printk 函数。仔细观察就可以发现，这个函数并没有直接实现输出，它只是把接受到的参数，以及outputk函数指针传入 vprintfmt 这个函数中。<br />
然后我们来看看 outputk 这个函数，这个函数实际上是用来输出一个字符串的，并且通过阅读可以发现，它实际上调用了一个叫做 printcharc 的函数。我们可以在 kern/machine.c 下面找到它的定义。<br />
最后可以发现，原来，想让控制台输出一个字符，实际上是对某一个内存地址写了一个字节。理解了以上之后，我们可以在 init.c 中直接调用 printcharc 来输出一个字符。</p></li>
</ol>
</section>
<section id="id13">
<h2><span class="section-number">2.5. </span>实验一正确结果<a class="headerlink" href="#id13" title="Link to this heading"></a></h2>
<p>使用make &amp;&amp; make run指令，若在qemu观察到输出</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">init</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="n">la32r_init</span><span class="p">()</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">called</span><span class="w"> </span>
</pre></div>
</div>
<p>使用make test lab=1_2 &amp;&amp; make run指令，观察到现象和 tests/lab1_2/init.c 中代码的输出一致，则代表顺利完成了Lab1实验。</p>
<img alt="lab1_2结果展示" class="bg-primary align-center" src="_images/lab1_2%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
</section>
</section>
<section id="id14">
<h1><span class="section-number">3. </span>实验二：内存管理<a class="headerlink" href="#id14" title="Link to this heading"></a></h1>
<section id="id15">
<h2><span class="section-number">3.1. </span>实验目的<a class="headerlink" href="#id15" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>了解loongarch64的访存流程</p></li>
<li><p>掌握与了解物理内存的管理方法（链表法）</p></li>
<li><p>掌握与实现虚拟内存的管理方法（二级页表）</p></li>
<li><p>掌握TLB清除与重填的流程</p></li>
</ol>
<p>物理内存（Physical Memory）是计算机上重要的硬件资源之一，用于在计算机运行过程中存储代码和数据。la64支持对 56MB 物理内存进行申请和释放。内核的二进制可执行代码被加载到 0x200000 地址处。<br />
处理器中的内存管理单元（Memory Management Unit，MMU）将CPU访问的虚拟地址转换为物理地址。LoongArch架构中的MMU支持两种地址转换模式：直接地址翻译模式和映射地址翻译模式。其中，映射地址翻译模式又包括直接映射地址翻译模式（以下简称直接映射）和页表映射地址翻译模式（以下简称页表映射）。当 MMU 处于映射地址翻译模式时，会优先选择直接映射，若无法进行直接映射，则选择页表映射。<br />
la64采用映射地址翻译模式进行虚拟地址到物理地址的转换。在内核态下采用直接映射，即虚拟地址与物理地址是一一映射关系；在用户态下采用页表映射。在设计中，二级页表作为一种内核数据结构放置于内存中，在用户程序需要访问虚拟地址时候（通过中断机制）内核负责将对应的页表项填入TLB。在 Lab2 中，我们的核心任务是管理二级页表与填写TLB。通过二级页表保存和描述虚拟地址与物理地址的映射关系，通过TLB加速虚拟地址到物理地址的转换。在本次实验中，我们将学习为什么需要两种地址转换模式，并实现页表的初始化、页表项的填写、TLB的清除与重填等功能。</p>
</section>
<section id="id16">
<h2><span class="section-number">3.2. </span>loongarch64的访存流程<a class="headerlink" href="#id16" title="Link to this heading"></a></h2>
<section id="cpu">
<h3><span class="section-number">3.2.1. </span>CPU发出地址<a class="headerlink" href="#cpu" title="Link to this heading"></a></h3>
<p>CPU 运行程序时通过访存指令发出访存请求，进行内存读写操作。在计算机组成原理等硬件实验中，CPU 通常直接发送物理地址，这是为了简化内存操作，让大家关注CPU内部的计算与控制逻辑。而在实际程序中，访存、跳转等指令以及用于取指的PC寄存器中的访存目标地址都是虚拟地址。我们编写的C程序中也经常通过对指针解引用来进行访存，其中指针的值也会被视为虚拟地址，经过编译后生成相应的访存指令。</p>
</section>
<section id="id17">
<h3><span class="section-number">3.2.2. </span>虚拟地址映射到物理地址<a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<p>正常情况下，处理器中的内存管理单元将CPU访问的虚拟地址转换为物理地址采用的是页表的形式，通过页表将一个虚拟地址层层寻找到物理地址。而页表的初始化和创建发生在内核程序中，但内核程序的启动代码也需要被放置到物理地址中，所以此时需要绕过页表通过另一种方式来进行虚拟地址到物理地址的映射。<br />
Loongarch64提供了一种直接地址翻译模式，通过直接映射配置窗口机制完成虚实地址的直接映射。直接映射配置窗口共设置有四个，系统软件通过配置 CSR.DMW0~CSR.DMW3 寄存器来分别设置四个直接映射配置窗口。每个窗口除了地址范围信息外，还可以配置该窗口在哪些特权等级下可用，以及虚地址落在该窗口上的访存操作的存储访问类型。<br />
打开init/start.S，其中含有以下代码，即是直接映射窗口配置以及处理器核MMU的映射地址翻译模式配置。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span>  <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0x9000000000000011</span>
<span class="mi">02</span>  <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw0</span>
 
<span class="mi">03</span>  <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0x0000000000000000</span>
<span class="mi">04</span>  <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw1</span>
<span class="mi">05</span>  <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw2</span>
<span class="mi">06</span>  <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_dmw3</span>
 
<span class="mi">07</span>  <span class="n">li</span><span class="o">.</span><span class="n">d</span>        <span class="n">a0</span><span class="p">,</span> <span class="mh">0xb0</span>
<span class="mi">08</span>  <span class="n">csrwr</span>       <span class="n">a0</span><span class="p">,</span> <span class="n">csr_crmd</span>
</pre></div>
</div>
<p>init/start.S 文件在实验一中也有叫重点阅读过，以上节选部分就是关于内存管理的内容，下面将详细解读。<br />
以上代码的1、2行，将 DMW0 寄存器的值设置为 0x9000000000000001，从而将内核态下使用的虚拟地址到物理地址的地址转换模式配置为直接映射。依照图中的值，将 PLV0 字段设置为1，表示将特权级PLV0配置为直接映射；将 VSEG 字段设置为9，表示将直接映射窗口的虚拟地址的 [63:60] 位设置为9。这样，内核态下的虚拟地址空间0x9000000000000000～ 0x9000FFFFFFFFFFFF和物理地址空间0x0～0xFFFFFFFFFFFF就建立了一一映射。例如，在内核态下，CPU访问虚拟地址0x9000000000200000时，MMU将该虚拟地址转换为物理地址0x200000。现在回头看kernel.lds文件，即可知道为什么内核代码放置位置是在0x9000000000200000位置，却被写入了 0x200000 了。<br />
代码的9、10行，将 0xb0 写入 CSR.CRMD 中，其中 DA（第三位）= 0，PG（第四位）= 1，表示处理器核的 MMU 处于映射地址翻译模式，也就是采用直接映射地址翻译模式以及页表映射地址翻译模式。<br />
而当内核进行了页表的初始化以及创建之后，进入用户态之中，由于特权级的不同，并且用户程序代码存放位置大多不在直接映射窗口的虚拟地址空间范围之内，因此用户态采用页表映射地址翻译模式。</p>
</section>
</section>
<section id="id18">
<h2><span class="section-number">3.3. </span>内核程序启动<a class="headerlink" href="#id18" title="Link to this heading"></a></h2>
<p>Lab1已经成功跳转到 la32r_init 函数，该函数实现位于 init/init.c 中。la32r_init() 函数中需要分别调用如下三个函数：</p>
<ul class="simple">
<li><p>la32r_detect_memory():作用是探测硬件可用内存，并对一些内核内存管理相关的变量进行初始化。</p></li>
<li><p>la32r_vm_init():作用是为内存管理机制作准备，建立一些用于管理的数据结构。</p></li>
<li><p>page_init():作用是初始化pages数组中的Page结构体以及空闲链表。
以上三个函数的实现都位于kern/pmap.c中，接下来的小节中将重点介绍前两个函数。</p></li>
</ul>
<section id="la32r-detect-memory">
<h3><span class="section-number">3.3.1. </span>la32r_detect_memory<a class="headerlink" href="#la32r-detect-memory" title="Link to this heading"></a></h3>
<p>La32r_detect_memory()，实现位于kern/pmap.c，作用是探测硬件可用内存，并对一些和内存管理相关的变量进行初始化。在“开机”之后，操作系统首先会探测硬件的可用内存。bootloader 实际上已经帮助我们完成了这件事情，在启动时，系统可用物理内存大小参数通过 ram_low_size 被传入, 我们只需要直接使用即可。<br />
在该函数中初始化的变量包括 memsize，表示总物理内存对应的字节数，npage 表示总物理页数，其中的一些变量定义位于 include/mmu.h 中。</p>
</section>
<section id="la32r-vm-init">
<h3><span class="section-number">3.3.2. </span>la32r_vm_init<a class="headerlink" href="#la32r-vm-init" title="Link to this heading"></a></h3>
<p>la32r_vm_init()，实现位于 kern/pmap.c。在调用la32r_detect_memory()探测完可用内存后，将开始建立内存管理机制。<br />
为了建立内存管理机制，需要调用到 alloc 函数，此函数同样位于 kern/pmap.c 中，此时还没有页式内存管理机制，操作系统也需要建立一些数据结构来管理内存，这就会涉及到内存空间的分配。alloc函数的功能就是用于分配内存空间（在建立页式内存管理机制之前使用）。alloc 函数的内容请自行理解，其中函数开始第一行代码中 extern char end[] 是一个定义在该文件之外的变量，并不在一个C代码文件中，而是在Lab1重点要阅读的 kernel.lds 中：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x9000000001200000</span><span class="p">;</span>
<span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">;</span>
</pre></div>
</div>
<p>也就是说该变量对应虚拟地址 0x9000000001200000，在建立内存管理机制时，本实验都是通过 DMW 访问内存。根据映射规则，0x9000000001200000 对应的物理地址是 0x1200000。 在物理地址 0x1200000 的前面，存放着操作系统内核的代码和定义的全局变量或数组（还额外保留了一些空间）。接下来将从物理地址 0x1200000 开始分配物理内存，用于建立管理内存的数据结构。<br />
回到 la32r_vm_init() 函数中。在函数中，完成了内存管理数据结构的空间分配。</p>
</section>
</section>
<section id="id19">
<h2><span class="section-number">3.4. </span>物理内存管理<a class="headerlink" href="#id19" title="Link to this heading"></a></h2>
<p>la64中的内存管理使用页式内存管理，采用链表法管理空闲物理页框。<br />
在实验中，内存管理的代码位于 kern/pmap.c 中。函数的声明位于 include/pmap.h 中。</p>
<section id="id20">
<h3><span class="section-number">3.4.1. </span>链表宏<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<p>在后续的Lab中，也有一些地方需要用到链表，因此la64中使用宏对链表的操作进行了封装，这部分功能非常有用，设计技巧应用广泛，大家需要仔细阅读代码，深入理解。<br />
链表宏的定义位于 <code class="docutils literal notranslate"><span class="pre">include/queue.h</span></code>，其实现了双向链表功能，下面将对一些主要的宏进行解释:</p>
<ul class="simple">
<li><p>LIST_HEAD(name, type)：创建一个名称为 name 链表的头部结构体，包含一个指向type 类型结构体的指针，这个指针可以指向链表的首个元素。</p></li>
<li><p>LIST_ENTRY(type)：作为一个特殊的类型出现，本质是一个链表项，包括指向下一个元素的指针 le_next，以及指向前一个元素链表项 le_next 的指针 le_prev。le_prev 是一个指针的指针，它的作用是当删除一个元素时，更改前一个元素链表项的 le_next。</p></li>
<li><p>LIST_ENPTY(head)：判断head指针指向的头部结构体对应的链表是否为空。</p></li>
<li><p>LIST_FIRST(head)：将返回head对应的链表的首个元素。</p></li>
<li><p>LIST_INIT(head)：将head对应的链表初始化。</p></li>
<li><p>LIST_NEXT(elm, field)：返回指针elm指向的元素在对应链表中的下一个元素的指针。elm 指针指向的结构体需要包含一个名为 field 的字段，类型是一个链表项 LIST_ENTRY(type)，下面出现的field含义均和此相同。</p></li>
<li><p>LIST_INSERT_AFTER(listelm, elm, field)：将 elm 插到已有元素 listelm 之后。</p></li>
<li><p>LIST_INSERT_BEFORE(listelm, elm, field)：将elm插到已有元素 listelm 之前。</p></li>
<li><p>LIST_INSERT_HEAD(head, elm, field)：将elm插到head对应链表的头部。</p></li>
<li><p>LIST_REMOVE(elm, field)：将elm从对应链表中删除。</p></li>
</ul>
</section>
<section id="id21">
<h3><span class="section-number">3.4.2. </span>页控制块<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<p>la64中维护了 npage 个页控制块，也就是 Page 结构体。每一个页控制块对应一页的物理内存，la64用这个结构体来按页管理物理内存的分配。<br />
将空闲物理页对应的 Page 结构体全部插入一个链表中，该链表被称为空闲链表，即 page_free_list。<br />
当一个进程需要分配内存时，就需要将空闲链表头部的页控制块对应的那一页物理内存分配出去，同时将该页控制块从空闲链表中删去。<br />
当一页物理内存被使用完毕（准确来说，引用次数为0）时，将其对应的页控制块重新插入到空闲链表的头部。<br />
结合 Page 结构体来理解页控制块，它的定义位于 include/pmap.h 中。</p>
</section>
<section id="id22">
<h3><span class="section-number">3.4.3. </span>其他相关函数<a class="headerlink" href="#id22" title="Link to this heading"></a></h3>
<p>在include/pmap.h中可以看到若干个以page_开头的函数。其中，有关物理内存管理的函数有4个，分别用来初始化物理页面管理、分配物理页面、减少物理页面引用、回收物理页面到空闲页面链表。<br />
它们的实现均位于 kern/pmap.c 中：</p>
<ul class="simple">
<li><p>page_init()：启动过程首先初始化了空闲页面链表，用于存储“没有被使用”的页控制块。需要申请内存空间时，就可以从没有被使用的页面中分配一页来使用。第二步按照页面对齐分配内存，接下接下来，将使用过的页面标记上引用次数，表示该页面被引用1次（可以通过已建立的页控制块数组访问）。将未被使用过的页面的页控制块加入空闲页面链表，供后续分配。</p></li>
<li><p>page_alloc(struct Page **pp)：它的作用是将 page_free_list 空闲链表头部页控制块对应的物理页面分配出去，将其从空闲链表中移除，并清空此页中的数据，最后将pp指向的空间赋值为这个页控制块的地址。</p></li>
<li><p>page_decref(struct Page *pp)：作用是令pp对应页控制块的引用次数减少1，如果引用次数为0则会调用 page_free 函数将对应物理页面重新设置为空闲页面。</p></li>
<li><p>page_free(struct Page *pp)：它的作用是将pp指向的页控制块重新插入到 page_free_list 中。此外需要先确保 pp 指向的页控制块对应的物理页面引用次数为0。</p></li>
</ul>
</section>
<section id="id23">
<h3><span class="section-number">3.4.4. </span>实验结果展示<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<p>执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=2_1</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code> 编译运行内核，出现如下输出即通过物理内存管理的单元测试：</p>
<img alt="lab2_1结果展示" class="bg-primary align-center" src="_images/lab2_1%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
</section>
</section>
<section id="id24">
<h2><span class="section-number">3.5. </span>虚拟内存管理<a class="headerlink" href="#id24" title="Link to this heading"></a></h2>
<p>通过阅读前面的代码，la64中使用 PADDR 与 KADDR 这两个宏可以对位于kseg0 （也就是dmw0范围内）的虚拟地址和对应的物理地址进行转换。<br />
但是，对于位于 kuseg （dmw0范围之外）的虚拟地址，la64中采用二级页表结构对其进行地址转换。</p>
<section id="id25">
<h3><span class="section-number">3.5.1. </span>二级页表结构<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<p>在二级页表结构中，第一级表称为页目录 (Page Directory) ，第二级表称为页表 (Page Table) 。为避免歧义，下面用一级页表指代 Page Directory，二级页表指代 Page Table。<br />
二级页表机制相比单极页表机制，将虚拟页号分为了两部分。<br />
具体来说，对于一个32位的虚拟地址，从低到高从0开始编号，其29~21位表示的是一级页表项的偏移量，20~12 位表示的是二级页表项的偏移量，11~0位表示的是页内偏移量。<br />
include/mmu.h 中提供了两个宏以快速获取偏移量，PDX(va) 可以获取虚拟地址 va 的 30~21 位，PTX(va) 可以获取虚拟地址 va 的 20~12 位。<br />
访问虚拟地址时，先通过一级页表基地址和一级页表项的偏移量，找到对应的一级页表项，得到对应的二级页表的物理页号，再根据二级页表项的偏移量找到所需的二级页表项，进而得到该虚拟地址对应的物理页号。<br />
la64 发出的地址均为虚拟地址，因此如果程序想访问某个物理地址，需要通过映射到该物理地址的虚拟地址来访问。对页表进行操作时硬件处于内核态，因此使用宏 KADDR 获得其位于 kseg0 中的虚拟地址即可完成转换。<br />
下面以将虚拟地址 0x12345678 转换为物理地址 0x5678 为例，详细介绍 MMU 利用二级页表结构进行地址转换的过程。虚拟地址 0x12345678 的页目录项索引、页表项索引和页内偏移分别为 0x91、0x145 和 0x678。地址转换过程中涉及的页目录、页表和物理页的起始物理地址分别为 0x1000、0x2000 和 0x5000，这3个物理地址分别存放在 PGDL 寄存器、0x91号PDE和 0x145 号 PTE 中。MMU 的转换过程如下：</p>
<img alt="二级页表转换过程图" class="bg-primary align-center" src="_images/MMU%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B.png" />
<ol class="arabic simple">
<li><p>MMU 从 PGDL 寄存器中获取页目录的起始物理地址 0x1000，将其与 0x91 号页目录项的偏移 0x488 相加，得到页目录项的物理地址 0x1488。</p></li>
<li><p>MMU 通过物理地址 0x1488 获取页目录项中页表的起始物理地址 0x2000 ，将其与 0x145 号页表项的偏移 0xA28 相加，得到页表项的物理地址 0x2A28。</p></li>
<li><p>MMU 通过物理地址 0x2A28 获取页表项中物理页的起始物理地址 0x5000，将其与页内偏移 0x678 相加，最终得到虚拟地址 0x12345678 对应的物理地址 0x5678。<br />
可能会有人不理解为什么每次从虚拟地址中取出索引量后都要乘以8，原因是la64的地址是64位的，每一个偏移量需要占8个字节，因此相当于乘上8。<br />
在la64中，无论是一级页表还是二级页表，它们的结构都一样，只不过每个页表项记录的物理页号含义有所不同。每个页表均由512个页表项组成，每个页表项由30位组成，包括18位物理页号以及12位标志位。详细解释如下：</p></li>
</ol>
<ul class="simple">
<li><p>第0位，存在位（v），或者叫做有效位，如果是0，说明此页表项不存在，任何匹配此表项的地址都会引起TLBL/TLBS异常。</p></li>
<li><p>第1位，脏位（D），如果是0，则表示存储在TLB中中的页表没被改写过，如果为1，则代表被改写了，需要写回内存。</p></li>
<li><p>第2和第3位，特权等级位（PLV），在 la64 中仅 PLV0 级可对应核心态，以 PLV3 级对应用户态。</p></li>
<li><p>第4和第5位，存储访问类型位（MAT），0表示强序非缓存，1表示一致可缓存，2表示弱序非缓存，3保留。</p></li>
<li><p>第6位，全局标志位（G），执行 TLBFILL 和 TLBWR 指令时，仅当 TLBELO0 和 TLBELO1 中的 G 位均为1时，填入到 TLB 中的页表项的 G 位才为1。执行 TLBRD 指令时，当所读取的 TLB 表项的 G 位为1，则 TLBELO0 和 TLBELO1 中 的 G 位被同时置为1。</p></li>
<li><p>第7位，页标志位(P)，表示页表项为页。</p></li>
<li><p>第8位，可写位(W)，表示写入保护，如果为0则不可写，如果为1则允许写入。</p></li>
<li><p>第9到第11位，保留位，只读恒为0，写被忽略。</p></li>
</ul>
<p>这里再复习一下 TLB 的功能。la64 中，通过页表进行地址变换时，硬件只会查询 TLB， 如果查找失败，就会触发 TLBMiss（TLB 缺失）异常，对应的异常中断处理程序就会对 TLB 进行重填。大家需要了解 loongarch64 虚拟地址映射的原理。需要特别注意的是，Lab2 中没有开启异常处理功能，我们仅对 TLB 重填过程进行模拟测试。这部分 TLB 相关的详细内容会在下面介绍。<br />
使用 tlb_invalidate 函数可以实现删除特定虚拟地址的映射，每当页表被修改，就需要调用该函数以保证下次访问相应虚拟地址时一定触发 TLB 重填，进而保证访存的正确性。<br />
除此之外，一般的操作系统中，当物理页全部被映射（所有内存空间均被占用），此时还需要申请新的物理页，那么就需要将一些在内存中的物理页置换到硬盘中，选择哪个物理页的算法就称为页面置换算法，例如 FIFO 算法和 LRU 算法。<br />
然而在 la64 中，这一过程的实现被简化，一旦物理页全部被分配，进行新的物理页分配时并不会进行任何的页面置换，而是直接返回错误，即在对应 page_alloc 函数中返回 -E_NO_MEM。</p>
</section>
<section id="id26">
<h3><span class="section-number">3.5.2. </span>与页表相关的函数<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<p>下面将介绍几个与页表相关的函数：
<strong>页表初始化</strong><br />
<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">page_init(void)</span></code>，之前介绍过 page_init 函数的功能，现在将目光聚焦到该函数的最后两行代码。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span>    <span class="n">asm</span> <span class="n">volatile</span><span class="p">(</span><span class="s2">&quot;csrwr %0, 0x1c&quot;</span> <span class="p">:</span> <span class="p">:</span> <span class="s2">&quot;r&quot;</span> <span class="p">((</span><span class="n">PTEWIDTH</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">DIR2WIDTH</span> <span class="o">&lt;&lt;</span> <span class="mi">25</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">DIR2BASE</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">DIR1WIDTH</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">DIR1BASE</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">PTWIDTH</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">PTBASE</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">);</span>  
<span class="mi">02</span>    <span class="n">asm</span> <span class="n">volatile</span><span class="p">(</span><span class="s2">&quot;invtlb 0x0,$r0,$r0&quot;</span><span class="p">);</span>  
</pre></div>
</div>
<p>从功能上不难看出，第一行代码作用是将一些宏定义数值写入一个寄存器中，这些宏定义具体的值可以在 include/asm/regdef.h 进行查看和更改。通过查看手册可以知晓，0x1c 代表的是 PWCL 寄存器，因为我们使用的仅仅是二级页表，所以只需要通过将页表信息写入 PWCL 寄存器的方式来实现对二级页表结构的初始化，而不用涉及到PWCH寄存器。<br />
如第一行代码所示，将 PWCL 寄存器的 PTbase 字段设置为12（PWCL_PBASE），表示虚拟地址中的页表项索引从第12位开始；将 PWCL 寄存器的 PTwidth 字段设置为9（PWCL_PTWIDTH），表示虚拟地址中的页表项索引的长度为9，即页内偏移位于虚拟地址的第0～11位，页表项索引位于虚拟地址的第12～20位；将 PWCL 寄存器的 Dir1_base 字段设置为21（PWCL_PDBASE），表示虚拟地址中的页目录项索引从第21位开始；将 PWCL 寄存器的 Dir1_width 字段设置为9（PWCL_PDWIDH），表示虚拟地址中的页目录项索引的长度为9，即页目录项索引位于虚拟地址的第21～29位。因此，在 la64 中，进程地址空间大小为29×29×212=1GB。将 PWCL 寄存器的 PTEwidth 字段设置为 0（PWCL_EWIDTH），表示页表项的大小为8B。<br />
具体对应如下图所示：</p>
<img alt="虚拟地址中的位和PWCL寄存器中字段的对应关系图" class="bg-primary align-center" src="_images/%E5%AF%84%E5%AD%98%E5%99%A8%E5%80%BC%E4%B8%8E%E9%A1%B5%E8%A1%A8%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" />
<p>page_init 函数的最后一行代码是在对用户态下使用的页表映射初始化完成后刷新 TLB。<br />
<strong>二级页表检索函数</strong><br />
int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte)，该函数将一级页表基地址 pgdir 对应的两级页表结构中 va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上。如果 create 不为0且对应的二级页表不存在，则会使用 page_alloc 函数分配一页物理内存用于存放二级页表，如果分配失败则返回错误码。<br />
<strong>增加地址映射函数</strong><br />
int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_longva, u_intperm)，作用是将一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 映射到页控制块 pp 对应的物理页面，并将页表项权限为设置为 perm。通过阅读可知，该函数实际上是调用了 pgdir_walk 函数，第一次调用查找 va 是否存在了映射，如果存在映射，该映射是否有效，如果存在的映射是有效的，那现有映射的页和需要插入的页是否一样，如果不一样，那么先移除现有的映射，后续再插入新的页，如果一样，就只需要更新一下映射的权限位。如果不存在映射，那么第二次调用 pgdir_walk 函数，并将 creat 传入参数为1，表示分配一页物理内存用于存放二级页表。<br />
<strong>寻找映射的物理地址函数</strong><br />
struct Page *page_lookup(Pde *pgdir, u_long va, Pte **ppte)，作用是返回一级页表基地址 pgdir 对应的二级页表页表结构中虚拟地址 va 映射的物理界面的页控制块，同时将 ppte 指向的空间设为对应的二级页表项地址。<br />
<strong>取消地址映射函数</strong><br />
void page_remove(Pde *pgdir, u_int asid, u_long va)，作用是删除一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 对物理地址的映射。如果存在这样的映射，那么对应物理页面的引用次数会减少一次。</p>
</section>
</section>
<section id="tlb">
<h2><span class="section-number">3.6. </span>访问内存与TLB重填<a class="headerlink" href="#tlb" title="Link to this heading"></a></h2>
<section id="id27">
<h3><span class="section-number">3.6.1. </span>TLB相关的前置知识<a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<p><strong>TLB组成</strong><br />
每个TLB表项都有两个组成部分，包括一组Key和两组Data。<br />
<strong>TLBELO0、TLBELO1、TLBEHI</strong><br />
TLBELO0、TLBELO1、TLBEHI都是寄存器，他们只是分别对应到 TLB 的 Key 与两组 Data，并不是 TLB 本身。<br />
因龙芯架构下 TLB 采用双页结构，所以 TLB 表项的低位信息对应奇偶两个物理页表项，其中偶数页信息在 TLBELO0 中，奇数页信息在 TLBELO1 中，而 TLBELO0 和 TLBELO1 寄存器的格式定义完全相同。</p>
</section>
<section id="id28">
<h3><span class="section-number">3.6.2. </span>TLB维护流程<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<p>通过之前的实验，大家可能仍然对软件访问内存的过程有所疑惑，这是由于还未涉及到用户进程相关的内容，所有代码、数据的虚拟地址均在dmw0段，无需通过页表的翻译便可直接获得其物理地址。因此本次实验中所完成的代码，大多是为之后的实验提供接口，本次实验中的一些内存管理功能只作为独立的函数存在。但由于内存访问将是之后实验中很重要的内容，在此次实验结束时，有必要将用户进程访问内存的流程解释清楚，既能帮助之后的实验，也能加深对本次实验的理解。<br />
本实验所使用的 MMU 硬件中只有 TLB，在用户地址空间访存时，虚拟地址到物理地址的转换均通过 TLB 进行。访问需要经过转换的虚拟内存地址时，首先要使用虚拟页号和当前进程的 ASID 在 TLB 中查询该地址对应的物理页号，如果虚页号和 ASID 组成的 Key 在 TLB 中存在对应的 TLB 表项（或虚页号在TLB中存在对应的 TLB 表项且表项权限位中的 G 位为1）时，则可取得物理地址；如果不能查询到，则产生 TLBMiss 异常，系统跳转到异常处理程序，在内核的两级页表结构中找到对应的物理地址，对 TLB 进行重填。<br />
操作系统可以修改页表中虚拟地址映射的物理页号或映射的权限位。如果 TLB 中已暂存了页表中某一虚拟地址对应的页表项内容，之后操作系统更新了该页表项，但没有更新 TLB，则访问该虚拟地址时实际可能会访问到错误的物理页面。所以我们需要维护 TLB 的表项，使得当 TLB 能够查询到虚拟地址相应的页号时，取得的物理页号和权限信息与实际在内核页表中对应的数据一致。<br />
因此，我们可以得到维护TLB的具体流程：</p>
<ol class="arabic simple">
<li><p>更新页表中虚拟地址对应的页表项的同时，将TLB中对应的旧表项无效化。</p></li>
<li><p>在下一次访问该虚拟地址时，硬件会触发 TLB 重填异常，此时操作系统对 TLB 进行重填。</p></li>
</ol>
<p><strong>TLB旧表项无效化</strong><br />
我们通过位于 kern/tlbex.c 中的 do_tlb_invalid 函数实现删除特定虚拟地址在 TLB 中的旧表项，函数的主要逻辑依靠位于 kern/tlb_asm.S 中的 tlb_invalidate函数。当 tlb_invalidate 被 do_tlb_invalid 调用时, a0 和 a1 寄存器中存放着传入的参数，其值为旧表项的 Key（由虚拟页号和 ASID 组成）。随后使用 invtlb 指令无效化 TLB 中的内容。<br />
<strong>TLB重填</strong><br />
TLB的重填过程由 kern/tlb_asm.S 中的 tlb_miss_entry 函数完成，具体代码如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span> <span class="n">tlb_miss_entry</span><span class="p">:</span>
<span class="mi">02</span> 
<span class="mi">03</span>         <span class="n">csrwr</span>   <span class="n">t0</span><span class="p">,</span> <span class="n">csr_tlbrsave</span>
<span class="mi">04</span>         <span class="n">csrrd</span>   <span class="n">t0</span><span class="p">,</span> <span class="n">csr_pgd</span>
<span class="mi">05</span>     <span class="n">lddir</span>       <span class="n">t0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">1</span>
<span class="mi">06</span>         <span class="n">srli</span><span class="o">.</span><span class="n">d</span>  <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">12</span>
<span class="mi">07</span>         <span class="n">slli</span><span class="o">.</span><span class="n">d</span>  <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">12</span>
<span class="mi">08</span>         <span class="n">ldpte</span>   <span class="n">t0</span><span class="p">,</span> <span class="mi">0</span>
<span class="mi">09</span>         <span class="n">ldpte</span>   <span class="n">t0</span><span class="p">,</span> <span class="mi">1</span>
<span class="mi">10</span>         <span class="n">tlbfill</span>
<span class="mi">11</span>         <span class="n">csrrd</span>   <span class="n">t0</span><span class="p">,</span> <span class="n">csr_tlbrsave</span>
<span class="mi">12</span> 
<span class="mi">13</span>         <span class="n">ertn</span>
<span class="mi">14</span> 
<span class="mi">15</span>         <span class="o">.</span><span class="n">size</span> <span class="n">tlb_miss_entry</span><span class="p">,</span> <span class="o">.-</span><span class="n">tlb_miss_entry</span>
</pre></div>
</div>
<p>首先保存 t0 寄存器的值，因为在 tlb_miss_entry 函数中使用了该寄存器。<br />
接着使用 csrrd 汇编指令，将 PGD 寄存器中保存的触发 TLB 重填例外的进程的页目录起始物理地址加载到 t0 寄存器中。<br />
随后使用 lddir 汇编指令，遍历页目录中触发 TLB 重填例外的虚拟地址对应的页目录项，并将该页目录项指向的页表起始物理地址加载到 t0 寄存器中。<br />
下面先使用右移指令，随后使用左移指令，每次位移位数相同，作用是将 t0 寄存器中的低12位清零。<br />
然后使用 ldpte 汇编指令，将页表中触发 TLB 重填例外的虚拟地址对应的2个页表项的内容写入 TLBRELO0 寄存器和 TLBRELO1 寄存器。<br />
后面使用 tlbfill 汇编指令，将 TLBRELO0 寄存器和 TLBRELO1 寄存器中存放的页表项信息填入到 TLB 中。<br />
最后恢复 t0 寄存器的值后，例外返回。<br />
中断、异常处理等过程将是之后实验的重点，现在可暂且将其理解为代码的跳转，到本节实验为止只需明白软件代码在访问内存时的处理过程即可。</p>
</section>
</section>
<section id="id29">
<h2><span class="section-number">3.7. </span>实验正确结果<a class="headerlink" href="#id29" title="Link to this heading"></a></h2>
<section id="id30">
<h3><span class="section-number">3.7.1. </span>实验代码功能解释<a class="headerlink" href="#id30" title="Link to this heading"></a></h3>
<p>大家需要自己仔细阅读测试代码，充分理解测试代码都做了什么，给本章学习做一个好的收尾。<br />
<strong>lab2_2</strong><br />
代码整体上是一个对物理页管理与页表映射机制进行强一致性、边界条件和引用计数验证的自检流程，用于在 la64 架构的内核初始化阶段严格校验 <code class="docutils literal notranslate"><span class="pre">page_alloc</span> <span class="pre">/</span> <span class="pre">page_free</span> <span class="pre">/</span> <span class="pre">page_insert</span> <span class="pre">/</span> <span class="pre">page_remove</span></code> 等核心内存管理原语是否实现正确。具体而言，<code class="docutils literal notranslate"><span class="pre">page_strong_check()</span></code> 先分配一页作为页目录并连续分配多页物理页，验证基本分配的唯一性；随后通过“暂时夺取”空闲页链表来人为制造内存耗尽场景，检查在无空闲页时页表分配与映射是否能正确失败，并在释放单个物理页后确认该页会被优先用作页表页。接着，该函数系统性地测试多种映射与重映射情况，包括同一物理页被映射到多个虚拟地址、重复插入同一映射、不同行为下引用计数的增减是否准确、页表页是否被正确创建和复用，以及在移除映射后物理页是否能被正确回收并重新分配。最后，它强制回收页目录和页表页，恢复空闲页链表并释放所有临时占用的页面，确保系统状态完全可逆、无资源泄漏。<code class="docutils literal notranslate"><span class="pre">la32r_init()</span></code> 则在系统启动时依次完成内存探测、虚拟内存初始化和页管理初始化，并通过先后调用 <code class="docutils literal notranslate"><span class="pre">page_check()</span></code> 与 <code class="docutils literal notranslate"><span class="pre">page_strong_check()</span></code> 来验证内存子系统的正确性，若全部断言通过则表明分页与物理页管理实现是健壮且符合设计预期的。<br />
<strong>lab2_3</strong><br />
代码整体实现了一个针对 la64 架构 TLB refill 与缺页异常处理路径的功能性自检，用于在内核初始化阶段验证页表建立、TLB 失效处理以及缺页时按需分配物理页的机制是否正确工作。代码首先分配并初始化一个新的页目录，将其同时写入相关 CSR 以作为当前活动页表基址，然后分配若干物理页并刻意清空空闲页链表，构造受控的内存环境；在已有页表页的前提下，测试基本的页映射与 <code class="docutils literal notranslate"><span class="pre">page_lookup</span></code>、<code class="docutils literal notranslate"><span class="pre">va2pa</span></code> 的一致性。随后，通过人为访问尚未建立映射的虚拟地址，显式调用 <code class="docutils literal notranslate"><span class="pre">do_tlb_invalid</span></code> 来模拟 TLB 无效或缺页异常，验证异常处理程序能够正确创建页表项、分配新的物理页并建立映射关系。最后，代码通过对新映射地址执行真实的读写操作，确认 TLB refill 机制已经生效、页表项被正确加载进 TLB 且内存访问行为符合预期。整体而言，该测试覆盖了从页表初始化、TLB 失效处理到缺页后可读写验证的完整路径，确保虚拟内存子系统在运行时具备正确的按需映射与 TLB 同步能力。</p>
</section>
<section id="id31">
<h3><span class="section-number">3.7.2. </span>正确实验结果展示<a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<p>在完成内存管理的学习后，执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=2_2</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code> 编译运行内核，显示如下图所示信息即通过内存管理的单元测试（其中地址7ffd000在不同实现下的值可能不同），也就是虚拟内存管理实验：</p>
<img alt="lab2_2实验结果图" class="bg-primary align-center" src="_images/lab2_2%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
<p>执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=2_3</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code> 编译运行内核，显示如下图所示信息即通过内存管理的 TLB 重填实验测试。</p>
<img alt="lab2_3实验结果图" class="bg-primary align-center" src="_images/lab2_3%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
</section>
</section>
</section>
<section id="id32">
<h1><span class="section-number">4. </span>实验三：进程与异常<a class="headerlink" href="#id32" title="Link to this heading"></a></h1>
<section id="id33">
<h2><span class="section-number">4.1. </span>实验目的<a class="headerlink" href="#id33" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>创造一个进程并成功运行。</p></li>
<li><p>实现时钟中断，通过时钟中断内核可以再次获得执行权。</p></li>
<li><p>实现进程调度，创建两个进程，并且通过时钟中断切换进程执行。</p></li>
</ol>
<p>在Lab3 中将运行一个用户模式的进程。<br />
本实验需要使用数据结构进程控制块 Env 来跟踪用户进程，并建立一个简单的用户进程，加载一个程序镜像到指定的内存空间，然后让它运行起来。<br />
同时，实验实现的 la64 内核具有处理异常的能力。</p>
</section>
<section id="id34">
<h2><span class="section-number">4.2. </span>进程<a class="headerlink" href="#id34" title="Link to this heading"></a></h2>
<p>整个 la64 并没有实现线程，因此本实验中进程既是基本的分配单元，也是基本的执行单元。每个进程都是一个实体，有其自己的地址空间，通常包括代码段、数据段和堆栈。程序是一个没有生命的实体，只有被操作系统赋予生命时，它才能成为一个活动的实体，而执行中的程序，就是进程。</p>
<section id="id35">
<h3><span class="section-number">4.2.1. </span>进程控制块<a class="headerlink" href="#id35" title="Link to this heading"></a></h3>
<p>进程控制块(PCB)是系统专门设置用来管理进程的数据结构，它可以记录进程的外部特征，描述进程的变化过程。系统利用 PCB 来控制和管理进程，所以 PCB 是系统感知进程存在的唯一标志。进程与 PCB 是一一对应的。在 la64 中，PCB 由一个 Env 结构体实现，主要包含如下一些信息：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Control</span> <span class="n">block</span> <span class="n">of</span> <span class="n">an</span> <span class="n">environment</span> <span class="p">(</span><span class="n">process</span><span class="p">)</span><span class="o">.</span>
<span class="n">struct</span> <span class="n">Env</span> <span class="p">{</span>
	<span class="n">struct</span> <span class="n">Trapframe</span> <span class="n">env_tf</span><span class="p">;</span>	 <span class="o">//</span> <span class="n">saved</span> <span class="n">context</span> <span class="p">(</span><span class="n">registers</span><span class="p">)</span> <span class="n">before</span> <span class="n">switching</span>
	<span class="n">LIST_ENTRY</span><span class="p">(</span><span class="n">Env</span><span class="p">)</span> <span class="n">env_link</span><span class="p">;</span>	 <span class="o">//</span> <span class="n">intrusive</span> <span class="n">entry</span> <span class="ow">in</span> <span class="s1">&#39;env_free_list&#39;</span>
	<span class="n">u_long</span> <span class="n">env_id</span><span class="p">;</span>			 <span class="o">//</span> <span class="n">unique</span> <span class="n">environment</span> <span class="n">identifier</span>
	<span class="n">u_long</span> <span class="n">env_asid</span><span class="p">;</span>			 <span class="o">//</span> <span class="n">ASID</span> <span class="n">of</span> <span class="n">this</span> <span class="n">env</span>
	<span class="n">u_long</span> <span class="n">env_parent_id</span><span class="p">;</span>		 <span class="o">//</span> <span class="n">env_id</span> <span class="n">of</span> <span class="n">this</span> <span class="n">env</span><span class="s1">&#39;s parent</span>
	<span class="n">u_long</span> <span class="n">env_status</span><span class="p">;</span>		 <span class="o">//</span> <span class="n">status</span> <span class="n">of</span> <span class="n">this</span> <span class="n">env</span>
	<span class="n">Pde</span> <span class="o">*</span><span class="n">env_pgdir</span><span class="p">;</span>			 <span class="o">//</span> <span class="n">page</span> <span class="n">directory</span>
	<span class="n">TAILQ_ENTRY</span><span class="p">(</span><span class="n">Env</span><span class="p">)</span> <span class="n">env_sched_link</span><span class="p">;</span> <span class="o">//</span> <span class="n">intrusive</span> <span class="n">entry</span> <span class="ow">in</span> <span class="s1">&#39;env_sched_list&#39;</span>
	<span class="n">u_long</span> <span class="n">env_pri</span><span class="p">;</span>			 <span class="o">//</span> <span class="n">schedule</span> <span class="n">priority</span>

	<span class="o">//</span> <span class="n">Lab</span> <span class="mi">4</span> <span class="n">IPC</span>
	<span class="n">u_long</span> <span class="n">env_ipc_value</span><span class="p">;</span>   <span class="o">//</span> <span class="n">the</span> <span class="n">value</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">us</span>
	<span class="n">u_long</span> <span class="n">env_ipc_from</span><span class="p">;</span>    <span class="o">//</span> <span class="n">envid</span> <span class="n">of</span> <span class="n">the</span> <span class="n">sender</span>
	<span class="n">u_long</span> <span class="n">env_ipc_recving</span><span class="p">;</span> <span class="o">//</span> <span class="n">whether</span> <span class="n">this</span> <span class="n">env</span> <span class="ow">is</span> <span class="n">blocked</span> <span class="n">receiving</span>
	<span class="n">u_long</span> <span class="n">env_ipc_dstva</span><span class="p">;</span>   <span class="o">//</span> <span class="n">va</span> <span class="n">at</span> <span class="n">which</span> <span class="n">the</span> <span class="n">received</span> <span class="n">page</span> <span class="n">should</span> <span class="n">be</span> <span class="n">mapped</span>
	<span class="n">u_long</span> <span class="n">env_ipc_perm</span><span class="p">;</span>    <span class="o">//</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">the</span> <span class="n">received</span> <span class="n">page</span> <span class="n">should</span> <span class="n">be</span> <span class="n">mapped</span>

	<span class="o">//</span> <span class="n">Lab</span> <span class="mi">4</span> <span class="n">fault</span> <span class="n">handling</span>
	<span class="n">u_long</span> <span class="n">env_user_tlb_mod_entry</span><span class="p">;</span> <span class="o">//</span> <span class="n">userspace</span> <span class="n">TLB</span> <span class="n">Mod</span> <span class="n">handler</span>

	<span class="o">//</span> <span class="n">Lab</span> <span class="mi">6</span> <span class="n">scheduler</span> <span class="n">counts</span>
	<span class="n">u_long</span> <span class="n">env_runs</span><span class="p">;</span> <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">times</span> <span class="n">we</span><span class="s1">&#39;ve been env_run&#39;</span><span class="n">ed</span>
<span class="p">};</span>
</pre></div>
</div>
<p>我们只对Lab3相关部分进行介绍，剩下的自行结合注释阅读：</p>
<ul class="simple">
<li><p>env_tf : 用于保存当前进程的上下文信息对应的结构体 Trapframe，该结构体的定义在 include/trap.h 中，在发生进程调度，或当陷入内核时，会将当时的进程上下文环境保存在 env_tf 变量中。</p></li>
<li><p>env_link : env_link 的机制类似于 Lab2 中的 pp_link，使用它来构造空闲进程链表 env_free_list。</p></li>
<li><p>env_id : 每个进程的 env_id 都不一样，它是进程独一无二的标识符。</p></li>
<li><p>env_parent_id : 在之后的实验中，我们将了解到进程是可以被其他进程创建的，创建本进程的进程称为父进程。此变量记录父进程的进程 id，进程之间通过此关联可以形成一棵进程树。</p></li>
<li><p>env_status : 该字段只能有以下三种取值：<br />
-ENV_FREE : 表明该进程控制块处于空闲状态，其没有被任何进程使用，即该进程控制块处于进程空闲链表中。<br />
-ENV_NOT_RUNNABLE : 表明该进程处于阻塞状态，处于该状态的进程需要在一定条件下变成就绪状态从而被 CPU 调度。（比如因进程通信阻塞时变为 ENV_NOT_RUNNABLE， 收到信息后变回 ENV_RUNNABLE）。<br />
-ENV_RUNNABLE : 该进程处于执行状态或就绪状态，即其可能是正在运行的，也可能正在等待被调度。</p></li>
<li><p>env_pgdir : 这个字段保存了该进程页目录的内核虚拟地址。</p></li>
<li><p>env_sched_link : 这个字段用来构造调度队列 env_sched_list。</p></li>
<li><p>env_pri : 这个字段保存了该进程的优先级。</p></li>
</ul>
<p>在实验中，存放进程控制块的物理内存在系统启动后就已经分配好，就是 envs 数组。<br />
和 Lab 2对页控制块数组的管理类似，我们使用链表管理进程控制块数组。struct Env 中的链表项共涉及调度队列 env_sched_list 和空闲队列 env_free_list 两个队列：</p>
<ul class="simple">
<li><p>env_sched_list : 为了便于管理已经被分配的进程控制块和对进程的调度，我们用链表将这些控制块串联起来，形成 env_sched_list。在进程创建时需要为其分配进程控制块 并加入 env_sched_list，在进程被释放时需要将其对应的进程控制块从 env_sched_list 移出。</p></li>
<li><p>env_free_list : 为了快速分配空闲的进程控制块，我们需要像 Lab2 一样将空闲的 Env 控制块按照链表形式串联起来，形成 env_free_list。一开始所有进程控制块都是空闲的，所以要把它们都串联到 env_free_list 上去。</p></li>
</ul>
<p>其中 env_free_list 使用了 Lab2 中涉及的 LIST 结构，而 env_sched_list 则使用了相似但不同的另一种结构 TAILQ，它同样定义在 include/queue.h 中，实现了一个双端队列，既支持在头部插入和取出，也支持在尾部插入和取出。你需要使用以 TAILQ 开头的宏来操作该队列。</p>
</section>
<section id="id36">
<h3><span class="section-number">4.2.2. </span>段地址映射<a class="headerlink" href="#id36" title="Link to this heading"></a></h3>
<p>在 env_init 函数的最后，使用 page_alloc 函数为模板页表 base_pgdir 分配了一页物理内存，将其转换为内核虚拟地址，并使用 map_segment 函数在该页表中将内核数组 pages 和 envs 映射到了用户空间的 UPAGES 和 UENVS 处。在之后的 env_setup_vm 函数中，我们会将这部分模板页表复制到每个进程的页表中。<br />
段地址映射函数 void map_segment(Pde *pgdir, u_int asid, u_long pa, u_long va, u_long size, u_int perm) ，功能是在一级页表基地址 pgdir 对应的两级页表结构中做段地址映射，将虚拟地址段 [va,va+size) 映射到物理地址段 [pa,pa+size) ，因为是按页映射，要求 size 必须是页面大小的整数倍。同时为相关页表项的权限为设置为 perm。它在这里的作用是将内核中的 Page 和 Env 数据结构映射到用户地址，以供用户程序读取。</p>
</section>
<section id="id37">
<h3><span class="section-number">4.2.3. </span>进程的标识<a class="headerlink" href="#id37" title="Link to this heading"></a></h3>
<p>现代计算机系统中经常有很多进程同时存在，每个进程执行不同的任务，它们之间也经常需要相互协作、通信，那么操作系统是如何识别每个进程呢？<br />
在本实验中我们依靠进程标识符来实现这一点。struct Env 进程控制块中的 env_id 域，是每个进程独一无二的标识符，需要在进程创建的时候就被赋予。<br />
env.c 文件中实现了一个叫做 mkenvid 的函数，作用就是生成一个新的进程env_id。<br />
la64 系统的进程控制块，还有一个 env_asid 域记录进程的 ASID，这是进程虚拟地址空间的标识。<br />
env_id 已经可以唯一标识进程，包括进程虚拟地址空间，为什么 la64 还需要引入额外的域作为虚拟地址空间的标识？<br />
系统中并发执行多个拥有不同虚拟地址空间的进程，具有不同的页表。而 CPU 的 MMU 使用 TLB 缓存虚拟地址映射关系，不同页表拥有不同虚拟地址映射，显然，不同进程的虚拟地址 可以对应相同的虚拟页号。当 CPU 切换页表，TLB 中仍可能缓存有之前页表的虚拟地址映射关系，这些映射关系可能与当前页表所描述的不一致，可以将其称为无效映射关系。为了避免 TLB 缓存的无效映射关系在页表切换后导致错误的地址翻译发生，早期操作系统实现在 CPU 每次切换页表时，无效化所有 TLB 表项。<br />
但这种实现会导致频繁的 TLB Miss，影响处理器性能。现代的 CPU 及操作系统，采用 ASID 解决上述问题。ASID 用于标识虚拟地址空间，同时并发执行的多个进程具有不同 ASID 以方便 TLB 标识其虚拟地址空间。<br />
正如 Lab2 中提到，TLB 实质上构建了一个 &lt;VPN, ASID&gt;—&gt;&lt;PFN, P, D, V, G&gt; 的映射。这里的 VPN 表示虚拟页号，PFN 表示物理页框号。TLB 存储进程的 ASID，作为 Key 的一部分，用于区别不同的虚拟地址空间中的映射。相当于每一个进程，都有自己虚拟地址空间（使用 ASID标识）下的一套独立 TLB 缓存，每次切换页表后，操作系统不必再清空所有 TLB 表项。<br />
由于 ASID 的唯一标识性，在实验中直到进程被销毁或 TLB 被清空时，才可以把其 ASID 分配给其他进程。</p>
</section>
<section id="id38">
<h3><span class="section-number">4.2.4. </span>设置进程控制块<a class="headerlink" href="#id38" title="Link to this heading"></a></h3>
<p>了解以上基础知识后，可以开始利用空闲进程链表 env_free_list 创建进程。下面具体介绍如何创建一个进程。<br />
进程创建的流程如下：</p>
<ol class="arabic simple">
<li><p>申请一个空闲的 PCB（也就是Env结构体），从 env_free_list 中索取一个空闲 PCB 块，这时候的 PCB 就像张白纸一样。</p></li>
<li><p>“纯手工打造”打造一个进程。在这种创建方式下，由于没有模板进程，所以进程拥有的所有信息都是手工设置。而进程的信息又都存放于进程控制块中，所以需要手工初始化进程控制块。</p></li>
<li><p>进程光有 PCB 的信息还没法跑起来，每个进程都有独立的地址空间。所以，要为新进程初始化页目录。</p></li>
<li><p>此时 PCB 已经被填写了很多东西，不再是一张白纸，把它从空闲链表里拿出，就可以使用。</p></li>
</ol>
<p>第二步的信息设置是本次实验的关键，阅读 kern/env.c 中的 env_alloc 函数，env_setup_vm 函数，我们需要初始化的字段已经在 env_alloc 函数的注释中给出，这个函数的重点在于我们已经给出的这个赋值 e-&gt;env_tf.crmd = CRMD_IE | CRMD_PLV。通过查看手册，可以知道 IE 位表示中断是否开启，为1表示开启，否则不开启。我们需要将 IE 设置为1，表示中断使能。此外，将 CRMD_PLV 写入 tf 中，因为每次触发中断后，程序会自动进入特权模式处理异常，设置 PLV 后，使用 ertn 指令可以回到用户模式中。之后第一个进程成功以用户模式运行，这时操作系统也可以正常响应中断了。</p>
</section>
<section id="id39">
<h3><span class="section-number">4.2.5. </span>加载二进制镜像<a class="headerlink" href="#id39" title="Link to this heading"></a></h3>
<p>在这一小节中，我们需要将程序加载到新进程的地址空间中。<br />
在 Lab1 中我们曾详细学习了 ELF 文件，它的类型有三种，一是可重定位文件，二是可执行文件，三是可被共享的对象文件。本节中的程序是指可执行文件。<br />
要想正确加载一个 ELF 文件到内存，只需将 ELF 文件中所有需要加载的程序段（program segment）加载到对应的虚拟地址上即可。我们已经写好了用于解析 ELF 文件的代码中的内容，你可以直接调用相应函数获取 ELF 文件的各项信息，并完成加载过程。相关函数和类型的声明如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">lib</span><span class="o">/</span><span class="n">elfloader</span><span class="o">.</span><span class="n">c</span>
<span class="n">const</span> <span class="n">Elf64_Ehdr</span> <span class="o">*</span><span class="n">elf_from_64b</span><span class="p">(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">binary</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="nb">int</span> <span class="n">elf_load_seg</span><span class="p">(</span><span class="n">Elf64_Phdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="nb">bin</span><span class="p">,</span> <span class="n">elf_mapper_t</span> <span class="n">map_page</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="o">//</span> <span class="n">kern</span><span class="o">/</span><span class="n">env</span><span class="o">.</span><span class="n">c</span>
<span class="n">static</span> <span class="n">void</span> <span class="n">load_icode</span><span class="p">(</span><span class="n">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">binary</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="n">static</span> <span class="nb">int</span> <span class="n">load_icode_mapper</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">va</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u_long</span> <span class="n">perm</span><span class="p">,</span> <span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">len</span><span class="p">);</span>
</pre></div>
</div>
<p>在 Lab3 阶段，我们还没有实现文件系统，因此无法直接操作磁盘中的 ELF 文件。在这里我们已经将 ELF 文件内容转化成了C数组的形式（可以在make后查看 user/bare/loop.b.c文件），这样可以通过编译到内核中完成加载。<br />
load_icode 函数负责加载可执行文件 binary 到进程 e 的内存中。它调用的 elf_from 函数完成了解析 ELF 文件头的部分，elf_load_seg 负责将 ELF 文件的一个 segment 加载到内存。<br />
为了达到这一目标，elf_load_seg 的最后两个参数用于接受一个自定义的回调函数 map_page，以及需要传递给回调函数的额外参数 data。每当 elf_load_seg 函数解析到一个需要加载到内存中的页面，会将有关的信息作为参数传递给回调函数，并由它完成单个页面的加载过程，而这里 load_icode_mapper 就是 map_page 的具体实现。<br />
load_icode 函数会从 ELF 文件中解析出每个 segment 的段头 ph，以及其数据在内存中的起始位置 bin，再由 elf_load_seg 函数将参数指定的程序段（program segment）加载到进程的地址空间中。<br />
elf_load_seg 函数会从 ph 中获取 va（该段需要被加载到的虚地址）、sgsize（该段在内存中的大小）、bin_size（该段在文件中的大小）和 perm（该段被加载时的页面权限），并根据这些信息完成以下两个步骤：</p>
<ol class="arabic simple">
<li><p>加载该段的所有数据（bin）中的所有内容到内存（va）。</p></li>
<li><p>如果该段在文件中的内容的大小达不到为填入这段内容新分配的页面大小，即分配了新的页面但没能填满（如.bss区域），那么余下的部分用 0 来填充。</p></li>
</ol>
<p>load_icode 函数通过调用 elf_load_seg 函数来将 ELF 文件真正加载到内存中，将 load_icode_mapper 这个函数作为参数传入。在该函数中出现了 e-&gt;env_tf.era = ehdr-&gt;e_entry 字段，该字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 e_entry，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。</p>
</section>
<section id="id40">
<h3><span class="section-number">4.2.6. </span>创建进程<a class="headerlink" href="#id40" title="Link to this heading"></a></h3>
<p>这里需要指出，“创建进程”是指在操作系统内核初始化时直接创建进程，而不是在通过 fork 等系统调用来创建进程。在 Lab4 中将介绍 fork 这一种进程创建的方式。创建进程的过程很简单，就是实现对上述个别函数的封装，分配一个新的 Env 结构体，设置进程控制块，并将程序载入到目标进程的地址空间即可完成。<br />
在 include/env.h 中，可以看到两个宏定义函数，#define ENV_CREATE_PRIORITY(x, y) 以及 #define ENV_CREATE(x) ，两个函数将二进制 ELF 文件的起始地址以及 ELF 文件大小传入 env_create 函数中，并可选定优先级。<br />
最后，可以在 init/init.c 中去掉注释，增加下面两句代码，在内核初始化时创建两个进程。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ENV_CREATE_PRIORITY</span><span class="p">(</span><span class="n">user_bare_loop</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  
<span class="n">ENV_CREATE_PRIORITY</span><span class="p">(</span><span class="n">user_bare_loop</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  
</pre></div>
</div>
<p>这里的 user_bare_loop 用于变量命名，对应的用户程序位于 user/bare/loop.S。经过 ENV_CREATE 宏的拼接后，得到内核中的 binary_user_bare_loop_start 数组和 binary_user_bare_loop_size 变量，我们可以在 make 时构建出的user/bare/loop.b.c文件中找到它们的定义。<br />
在创建进程前，记得调用 env_init 初始化进程管理。</p>
</section>
<section id="id41">
<h3><span class="section-number">4.2.7. </span>进程运行与切换<a class="headerlink" href="#id41" title="Link to this heading"></a></h3>
<p>在 kern/env.c 中可以找到 env_run 函数，该函数是进程运行使用的基本函数，它包括两部分：</p>
<ul class="simple">
<li><p>保存当前进程上下文（如果当前没有运行的进程就跳过这一步）</p></li>
<li><p>恢复要启动的进程的上下文，然后运行该进程。</p></li>
</ul>
<p>其实我们这里运行一个新进程往往意味着是进程切换，而不是单纯的进程运行。进程切换，顾名思义，就是当前进程停下工作，让出 CPU 来运行另外的进程。那么要理解进程切换，我们就要知道进程切换时系统需要做些什么。实际上进程切换的时候，为了保证下一次进入这个进程的时候我们不会再“从头来过”，而是有记忆地从离开的地方继续往后走，我们要保存一些信息， 那么，需要保存什么信息呢？事实上，我们只需要保存进程的上下文信息，包括通用寄存器、HI、 LO和 CRMD、BadVAddr 寄存器。进程控制块除了env_tf其他的字段在进程切换后还保留在原本的进程控制块中，并不会改变，因此不需要保存。<br />
在 Lab3 中，我们在本实验里的寄存器状态保存的地方是 KSTACKTOP 以下的一个 sizeof(TrapFrame) 大小的区域中。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_tf</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">structTrapframe</span> <span class="o">*</span><span class="p">)</span><span class="n">KSTACKTOP</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
</pre></div>
</div>
<p>代码中的 curenv-&gt;env_tf 就是当前进程的上下文所存放的区域。我们将把 KSTACKTOP 之下的 Trapframe 拷贝到当前进程的 env_tf 中，以达到保存进程上下文的效果。<br />
总结以上说明，我们不难看出 env_run 的执行流程：</p>
<ol class="arabic simple">
<li><p>保存当前进程的上下文信息。</p></li>
<li><p>切换curenv为即将运行的进程。</p></li>
<li><p>设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。</p></li>
<li><p>调用 env_pop_tf 函数，恢复现场、异常返回。</p></li>
</ol>
<p>这里用到的 <code class="docutils literal notranslate"><span class="pre">env_pop_tf</span></code> 是定义在 kern/env_asm.S 中的一个汇编函数，建议大家去自己阅读并理解其含义。这个函数也呼应了我们前文提到的，进程每次被调度运行前一定会执行的 <code class="docutils literal notranslate"><span class="pre">ertn</span></code> 汇编指令。<br />
至此，第一部分学习已经完成。</p>
</section>
<section id="id42">
<h3><span class="section-number">4.2.8. </span>实验正确结果<a class="headerlink" href="#id42" title="Link to this heading"></a></h3>
<p>大家要自行阅读和理解测试代码，搞清楚测试代码中的函数调用关系，理解函数功能以及作用。<br />
执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=3_1</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code> 编译运行内核，显示如下信息即通过 <code class="docutils literal notranslate"><span class="pre">env_init</span></code> 的单元测试：</p>
<img alt="lab3_1实验结果图" class="bg-primary align-center" src="_images/lab3_1%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
<p>执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=3_2</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code> 编译运行内核,显示如下信息即通过 <code class="docutils literal notranslate"><span class="pre">load_icode</span></code> 的单元测试：</p>
<img alt="lab3_2实验结果图" class="bg-primary align-center" src="_images/lab3_2%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
</section>
</section>
<section id="id43">
<h2><span class="section-number">4.3. </span>中断与例外<a class="headerlink" href="#id43" title="Link to this heading"></a></h2>
<p>龙芯架构下的中断采用线中断的形式。每个处理器核内部可记录13个线中断，分别是：1个核间中断（IPI），1 个定时器中断（TI），1个性能监测计数溢出中断（PMI），8个硬中断（HWI0~HWI7），2个软中断（SWI0~SWI1）。所有的线中断都是电平中断，且都是高电平有效。<br />
在龙芯架构下，控制状态寄存器中的 0x5，ESTAT 例外状态寄存器，记录了中断状态位以及例外类型编码，如下图所示：</p>
<img alt="例外状态寄存器定义表" class="bg-primary align-center" src="_images/%E4%BE%8B%E5%A4%96%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E5%AE%9A%E4%B9%89.png" />
<p>由图表可知，寄存器的第0~13位记录了发生的中断情况，第16~21位则记录了发生的例外情况，其中如果 <code class="docutils literal notranslate"><span class="pre">Ecode</span></code> 值为0x0，则表示为中断，这也就是两者的联系。我们实验里认为中断是例外的一种，并且是仅有的一种异步例外（请读者自行去了解同步和异步的区别）。<br />
la64处理一个例外时大致要完成四项工作：</p>
<ol class="arabic simple">
<li><p>设置 ERA，指向从异常返回的地址。</p></li>
<li><p>设置 CRMD，强制 CPU 进入内核态（行使更高级的特权）并禁止中断和例外。</p></li>
<li><p>设置 ESTAT 例外状态寄存器，用于记录中断以及例外发生的原因。</p></li>
<li><p>CPU 开始从异常入口位置取指，此后一切交给软件处理。</p></li>
</ol>
<p>而这个“一切交给软件处理”，就是我们操作系统要完成的事情。</p>
<section id="id44">
<h3><span class="section-number">4.3.1. </span>例外的分发<a class="headerlink" href="#id44" title="Link to this heading"></a></h3>
<p>当发生例外时，处理器会进入一个用于分发例外的程序，这个程序的作用就是检测发生了哪种例外，并调用相应的例外处理程序。一般来说，例外分发程序会被要求放在固定的某个物理地址上（根据处理器的区别有所不同），以保证处理器能在检测到异常时正确地跳转到那里。这个分发程序可以认为是操作系统的一部分。<br />
下述代码就是例外分发代码，处在 kern/entry.S 中，下面分析其功能。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">exc_gen_entry</span><span class="p">:</span>
	<span class="n">SAVE_ALL</span>
	<span class="n">csrrd</span>   <span class="n">t0</span><span class="p">,</span> <span class="n">csr_estat</span>
	<span class="n">srli</span><span class="o">.</span><span class="n">d</span>  <span class="n">t0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">16</span>
	<span class="n">andi</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mh">0x3f</span>
	<span class="n">slli</span><span class="o">.</span><span class="n">d</span>  <span class="n">t0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">3</span>
	<span class="n">la</span>      <span class="n">t1</span><span class="p">,</span> <span class="n">exception_handlers</span>
	<span class="n">add</span><span class="o">.</span><span class="n">d</span>   <span class="n">t1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span>
	<span class="n">ld</span><span class="o">.</span><span class="n">d</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="mi">0</span>
	<span class="n">jr</span>      <span class="n">t0</span>
</pre></div>
</div>
<p>这段例外分发代码的作用流程如下：</p>
<ol class="arabic simple">
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">SAVE_ALL</span></code> 宏将当前上下文保存到内核的异常栈中。</p></li>
<li><p>将 <code class="docutils literal notranslate"><span class="pre">ESTAT</span></code> 寄存器的内容拷贝到t0寄存器中。</p></li>
<li><p>取得 <code class="docutils literal notranslate"><span class="pre">ESTAT</span></code> 寄存器的16~21位，也就是对应的例外码，这是区别不同例外的重要标志。</p></li>
<li><p>以取得的例外码作为索引在 <code class="docutils literal notranslate"><span class="pre">exception_handlers</span></code> 数组中找到对应的中断处理函数，后文中会有涉及。</p></li>
<li><p>跳转到对应的例外处理函数中，也就是响应了例外，并将例外交给了对应的例外处理函数去处理。</p></li>
</ol>
<p>这里出现了一个新的宏 <code class="docutils literal notranslate"><span class="pre">SAVE_ALL</span></code>，该宏在后面的 Lab 中也会使用，用于将当前的 CPU 现场（上下文）保存到内核的异常栈中，我们可以在 <code class="docutils literal notranslate"><span class="pre">include/stackframe.h</span></code> 文件中查看这个宏的定义。<br />
在 <code class="docutils literal notranslate"><span class="pre">SAVE_ALL</span></code> 的执行过程中，我们首先判断当前异常是否是在内核态触发的，即是否发生了例外重入。具体而言，代码首先通过 <code class="docutils literal notranslate"><span class="pre">csrrd</span></code> 指令将 <code class="docutils literal notranslate"><span class="pre">csr_prmd</span></code>（例外前的处理器模式寄存器）的值读入临时寄存器 <code class="docutils literal notranslate"><span class="pre">$r21</span></code>（即 x， 定义位于 <code class="docutils literal notranslate"><span class="pre">include/asm/regdef.h</span></code> 中），并使用 <code class="docutils literal notranslate"><span class="pre">andi</span></code> 指令提取其最低两位，用于判断例外发生前的特权级。如果该值为 0，则表示例外是在内核态触发的，属于例外重入的情况。对于例外重入的情况，此时 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 寄存器已经指向当前的内核异常栈，因此无需切换栈指针。代码将当前的 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 保存到即将构建的 trapframe 中对应的 <code class="docutils literal notranslate"><span class="pre">TF_REG3</span></code> 位置，随后继续执行后续保存现场的流程。而对于非例外重入的情况，即例外是在用户态触发的，<code class="docutils literal notranslate"><span class="pre">sp</span></code> 此时仍指向用户栈。代码会先将 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 切换为内核例外栈顶 <code class="docutils literal notranslate"><span class="pre">KSTACKTOP</span> <span class="pre">-</span> <span class="pre">TF_SIZE</span></code>，并在切换之前，将原用户态的 <code class="docutils literal notranslate"><span class="pre">sp</span></code> 值保存到 trapframe 中的 <code class="docutils literal notranslate"><span class="pre">TF_REG3</span></code> 字段，从而保证用户栈指针不会丢失。完成例外重入判断与栈指针处理后，代码继续将关键的控制状态寄存器（包括 <code class="docutils literal notranslate"><span class="pre">csr_prmd</span></code>、<code class="docutils literal notranslate"><span class="pre">csr_estat</span></code>、<code class="docutils literal notranslate"><span class="pre">csr_era</span></code> 和 <code class="docutils literal notranslate"><span class="pre">csr_badv</span></code>）以及所有通用寄存器依次保存到 trapframe 中，为后续的异常处理与上下文恢复提供完整的处理器状态。<br />
<code class="docutils literal notranslate"><span class="pre">.text.exc_gen_entry</span></code> 段和 <code class="docutils literal notranslate"><span class="pre">.text.tlb_miss_entry</span></code> 段需要被链接器放到特定的位置，它们是异常处理程序的入口地址。在我们的系统中，CPU 发生例外（除了用户态地址的 <code class="docutils literal notranslate"><span class="pre">TLBMiss</span></code> 例外）后，就会自动跳转到 <code class="docutils literal notranslate"><span class="pre">exc_gen_entry</span></code> 函数所在地址处；发生用户态地址的 <code class="docutils literal notranslate"><span class="pre">TLBMiss</span></code> 例外时，会自动跳转到 <code class="docutils literal notranslate"><span class="pre">tlb_miss_entry</span></code> 函数所在地址处。开始执行。<br />
我们可以在 <code class="docutils literal notranslate"><span class="pre">kernel.lds</span></code> 中看到这两个函数是如何被放置到特定位置的，其具体实现位于 <code class="docutils literal notranslate"><span class="pre">kern/entry.S</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">kern/tlb_asm.S</span></code>，这两个函数为操作系统增加了例外分发功能。</p>
</section>
<section id="id45">
<h3><span class="section-number">4.3.2. </span>例外向量组<a class="headerlink" href="#id45" title="Link to this heading"></a></h3>
<p>例外分发程序通过 <code class="docutils literal notranslate"><span class="pre">exception_handlers</span></code> 数组定位中断处理程序，而 <code class="docutils literal notranslate"><span class="pre">exception_handlers</span></code> 就称作例外向量组。<br />
下面我们来看一下 <code class="docutils literal notranslate"><span class="pre">kern/traps.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">exception_handlers</span></code> 数组，来了解异常向量组里存放了什么。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="n">void</span> <span class="n">handle_int</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">handle_tlb</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">handle_sys</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">handle_mod</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">handle_reserved</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>

<span class="n">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exception_handlers</span><span class="p">[</span><span class="mi">64</span><span class="p">])(</span><span class="n">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="mi">0</span> <span class="o">...</span> <span class="mi">63</span><span class="p">]</span> <span class="o">=</span> <span class="n">handle_reserved</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">handle_int</span><span class="p">,</span>   <span class="p">[</span><span class="mi">1</span> <span class="o">...</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">handle_tlb</span><span class="p">,</span>
<span class="c1">#if !defined(LAB) || LAB &gt;= 4</span>
    <span class="p">[</span><span class="mh">0x4</span><span class="p">]</span> <span class="o">=</span> <span class="n">handle_mod</span><span class="p">,</span>		  <span class="p">[</span><span class="mh">0xb</span><span class="p">]</span> <span class="o">=</span> <span class="n">handle_sys</span><span class="p">,</span>
<span class="c1">#endif</span>
<span class="p">};</span>
</pre></div>
</div>
<p>上述代码使用了 <code class="docutils literal notranslate"><span class="pre">GNU</span> <span class="pre">C</span></code> 的拓展语法 <code class="docutils literal notranslate"><span class="pre">[first</span> <span class="pre">...</span> <span class="pre">last]</span> <span class="pre">=</span> <span class="pre">value</span></code> 来对数组某个区间上的元素赋成同一个值。举例来说，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span> <span class="o">...</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>  
</pre></div>
</div>
<p>这一句等价于下面的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>  
</pre></div>
</div>
<p>通过把相应处理函数的地址填到对应数组项中，我们初始化了如下例外：<br />
<strong>0号例外</strong> 的处理函数为 <strong>handle_int</strong>，表示中断，由时钟中断、控制台中断等中断造成<br />
<strong>1号例外</strong> 的处理函数为 <strong>handle_mod</strong>，表示存储例外，进行存储操作时该页被标记为只读<br />
<strong>2号例外</strong> 的处理函数为 <strong>handle_tlb</strong>，表示 <code class="docutils literal notranslate"><span class="pre">TLB</span> <span class="pre">load</span></code> 例外<br />
<strong>3号例外</strong> 的处理函数为 <strong>handle_tlb</strong>，表示 <code class="docutils literal notranslate"><span class="pre">TLB</span> <span class="pre">store</span></code> 例外<br />
<strong>8号例外</strong> 的处理函数为 <strong>handle_sys</strong>，表示系统调用，用户进程通过执行 <code class="docutils literal notranslate"><span class="pre">syscall</span></code> 指令陷入内核<br />
一旦初始化结束，有例外产生，那么其对应的处理函数就会得到执行。而我们在本 Lab 中，主要使用0号例外，即中断例外的处理函数（对于2、3号异常，在Lab2的相关内容中有所介绍）。而我们接下来要做的，就是产生并处理时钟中断，利用时钟中断进行抢占式进程调度。</p>
</section>
<section id="id46">
<h3><span class="section-number">4.3.3. </span>时钟中断<a class="headerlink" href="#id46" title="Link to this heading"></a></h3>
<p>在前面的介绍中我们已经知道 <code class="docutils literal notranslate"><span class="pre">ESTAT</span></code> 寄存器中有11个独立的中断位。其中8位是硬件中断，另外3位是软件中断，且不同中断处理起来也会有差异。所以在完成这一部分内容之前，我们首先来介绍一下中断处理的流程。</p>
<ol class="arabic simple">
<li><p>通过例外分发，判断出当前异常为中断例外，随后进入相应的中断处理程序。在 <code class="docutils literal notranslate"><span class="pre">la64</span></code> 中即对应 <code class="docutils literal notranslate"><span class="pre">handle_int</span></code> 函数。</p></li>
<li><p>在中断处理程序中进一步判断 <code class="docutils literal notranslate"><span class="pre">ESTAT</span></code> 寄存器中是由几号中断位引发的中断，然后进入不同中断对应的中断服务函数。</p></li>
<li><p>中断处理完成，通过 <code class="docutils literal notranslate"><span class="pre">ret_from_exception</span></code> 函数恢复现场，继续执行。</p></li>
</ol>
<p>上面涉及到的函数定义在 <code class="docutils literal notranslate"><span class="pre">kern/genex.S</span></code> 中。<br />
下面我们来简单介绍一下时钟中断的概念，为什么 ‘la64’ 系统需要时钟中断。<br />
时钟中断与 ‘la64’ 系统的时间片轮转调度算法是紧密相关的。时间片轮转调度是一种进程调度算法，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则该进程将挂起，切换到另一个进程运行。如果该进程在时间片结束前阻塞或者结束，则立即切换到另一个进程运行。<br />
‘la64’ 是如何知晓一个进程的时间片结束的呢？就是通过硬件定时器产生的时钟中断。在 ‘la64’ 中，时间片的长度是用时钟中断衡量的。比如设定某个进程的时间片的长度为200倍的 ‘TIMER_INTERVAL’（时钟中断间隔），那么当 ‘la64’ 记录到该进程的执行中发生了200个时钟中断时，’la64’ 就知晓该进程的时间片结束了。<br />
当时钟中断产生时，当前运行的进程被挂起，’la64’ 需要在调度队列中选取一个合适的进程运行。<br />
‘LoongArch’ 架构提供了用于产生时钟中断的恒定频率定时器（以下简称定时器）。在使用定时器前，需要为其设定1个自减初始值，定时器会按照固定频率进行自减操作，当自减到0时，产生时钟中断信号。’include/kclock.h’ 中的 ‘RESET_KCLOCK’ 宏完成了对定时器的配置。<br />
下面将对时钟初始化相关函数进行解释，首先看到 ‘start.S’ 函数中的以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">li</span><span class="o">.</span><span class="n">d</span>    	<span class="n">t0</span><span class="p">,</span> <span class="n">ESTAT_TI</span>
	<span class="n">csrwr</span>   	<span class="n">t0</span><span class="p">,</span> <span class="n">csr_ectl</span>
</pre></div>
</div>
<p>然后是 ‘include/kclock.h’ 中的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define TIMER_CONFIG (0xfffd)</span>
<span class="o">.</span><span class="n">macro</span> <span class="n">RESET_KCLOCK</span>
	<span class="n">li</span><span class="o">.</span><span class="n">d</span>    <span class="n">t0</span><span class="p">,</span> <span class="n">TIMER_CONFIG</span>
	<span class="n">csrwr</span>	<span class="n">t0</span><span class="p">,</span> <span class="n">csr_tcfg</span>
<span class="o">.</span><span class="n">endm</span>
</pre></div>
</div>
<p>实现时钟中断的使能需要配置2个寄存器：’ECFG’ 寄存器和 ‘CRMD’ 寄存器。其中，’ECFG’ 寄存器用于使能局部中断，’CRMD’ 寄存器用于使能全局中断。如前所述LoongArch架构支持13个中断，每个中断都有一个局部中断使能位，总共13位，分别对应 ‘ECFG’ 寄存器的 ‘LIE’ 字段中的13位，其中，定时器中断对应第11位。<br />
而通过写 ‘TCFG’ 寄存器中的字段，就可以进行定时器的配置。 ‘TCFG’寄存器需要配置的字段包括定时器倒计时自减的初始值 ‘InitVal’、循环模式控制位 ‘Periodic’ 和定时器使能位 ‘EN’。</p>
<ul class="simple">
<li><p>InitVal：定时器倒计时自减计数的初始值。硬件将该值左移2位后的值作为最终的定时器的自减初始值。例如，若将 ‘InitVal’ 字段设置为1，则定时器的自减初始值为4，即定时器在自减4次后，产生时钟中断信号。</p></li>
<li><p>Periodic：循环模式控制位。若该位为1，则定时器在倒计时自减至0时，在产生时钟中断信号的同时，将定时器的自减初始值重新加载为InitVal字段中的值左移2位后的值，然后在下一个时钟周期重新自减。若该位为0，则自减至0时，在产生定时器中断信号后停止自减。</p></li>
<li><p>EN：定时器使能位。只有当该位为1时，定时器才会进行倒计时自减，并在减至0时，产生定时器中断信号。</p></li>
</ul>
<p>详细位数如下图所示:</p>
<img alt="定时器配置寄存器定义表" class="bg-primary align-center" src="_images/%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%AE%9A%E4%B9%89.png" />
<p>总的来说，<code class="docutils literal notranslate"><span class="pre">RESET_KCLOCK</span></code> 宏完成了对定时器的配置。在设定好的时钟周期后，时钟中断将被触发。<code class="docutils literal notranslate"><span class="pre">la64</span></code> 中，时钟中断的初始化发生在调度执行每一个进程之前。从代码角度，就是在 <code class="docutils literal notranslate"><span class="pre">env_pop_tf</span></code> 中调用了宏 <code class="docutils literal notranslate"><span class="pre">RESET_KCLOCK</span></code>，随后又在宏 <code class="docutils literal notranslate"><span class="pre">RESTORE_ALL</span></code> 中恢复了 <code class="docutils literal notranslate"><span class="pre">CRMD</span></code> 寄存器，开启了中断。<br />
一旦时钟中断产生，就会触发硬件的异常中断处理流程。系统将 PC 指向 <code class="docutils literal notranslate"><span class="pre">exc_gen_entry</span></code> 函数所在地址，跳转到 <code class="docutils literal notranslate"><span class="pre">.text.exc_gen_entry</span></code> 代码段执行。对于时钟引起的中断，通过 <code class="docutils literal notranslate"><span class="pre">.text.exc_gen_entry</span></code> 代码段的分发，最终会调用 <code class="docutils literal notranslate"><span class="pre">handle_int</span></code> 函数进行处理。<br />
<code class="docutils literal notranslate"><span class="pre">handle_int</span></code> 函数根据 <code class="docutils literal notranslate"><span class="pre">ESTAT</span></code> 寄存器的值判断是否是 <code class="docutils literal notranslate"><span class="pre">Timer</span></code> 对应的11号中断位引发的时钟中断，如果是，则执行中断服务函数 <code class="docutils literal notranslate"><span class="pre">timer_irq</span></code> ，跳转到 <code class="docutils literal notranslate"><span class="pre">schedule</span></code> 中执行。这个函数就是我们将要学习的调度函数。</p>
</section>
<section id="id47">
<h3><span class="section-number">4.3.4. </span>进程调度<a class="headerlink" href="#id47" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">handle_int</span></code> 函数的最后跳转到了 <code class="docutils literal notranslate"><span class="pre">schedule</span></code> 函数。这个函数在 <code class="docutils literal notranslate"><span class="pre">kern/sched.c</span></code> 中所定义，它就是我们本次实验最后要学习的调度函数。调度的算法很简单，就是时间片轮转的算法。上文提到，<code class="docutils literal notranslate"><span class="pre">la64</span></code> 中的时间片的长度是用时钟中断衡量的，即时间片长度被量化为 <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">×</span> <span class="pre">TIMER_INTERVAL</span></code>。具体的，<code class="docutils literal notranslate"><span class="pre">env</span></code> 中的优先级即为这里的 N，规定了该进程的时间片长度。不过寻找就绪状态进程不是简单遍历所有进程，而是用一个调度链表存储所有就绪（可运行）的进程，即一个进程在调度链表中当且仅当这个进程是就绪（ENV_RUNNABLE）状态的。当内核创建新进程时，将其插入调度链表的头部；在其不再就绪（被阻塞）或退出时，将其从调度链表中移除。<br />
调度函数 <code class="docutils literal notranslate"><span class="pre">schedule</span></code> 被调用时，当前正在运行的进程被存储在全局变量 <code class="docutils literal notranslate"><span class="pre">curenv</span></code> 中（在第一个进程被调度前为NULL），其剩余的时间片长度被存储在静态变量 <code class="docutils literal notranslate"><span class="pre">count</span></code> 中。我们考虑是否需要进行进程切换，包括以下几种情况：</p>
<ul class="simple">
<li><p>尚未调度过任何进程（curenv为空指针）；</p></li>
<li><p>当前进程已经用完了时间片；</p></li>
<li><p>当前进程不再就绪（如被阻塞或退出）；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">yield</span></code> 参数指定必须发生切换。</p></li>
</ul>
<p>无需进行切换时，我们只需要将剩余时间片长度 <code class="docutils literal notranslate"><span class="pre">count</span></code> 减去1，然后调用 <code class="docutils literal notranslate"><span class="pre">env_run</span></code> 函数，继续运行当前进程 <code class="docutils literal notranslate"><span class="pre">curenv</span></code>。在发生切换的情况下，我们还需要判断当前进程是否仍然就绪，如果是则将其移动到调度链表的尾部。之后，我们选中调度链表首部的进程来调度运行，将剩余时间片长度设置为其优先级。<br />
至此，我们的Lab3就算是圆满完成了。</p>
</section>
</section>
<section id="id48">
<h2><span class="section-number">4.4. </span>代码导读<a class="headerlink" href="#id48" title="Link to this heading"></a></h2>
<p>Lab3 涉及到了内核态以及用户态的切换，还有不同进程寄存器之间的切换，需要大家仔细学习、理解，为了帮助理清 Lab3 代码逻辑和执行流程，我们在这里给出代码导读部分。<br />
Lab3 在 Lab2 基础上增加了两个代码段，叫做 <code class="docutils literal notranslate"><span class="pre">.tlb_miss_entry</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.exc_gen_entry</span></code>，其代码定义在 <code class="docutils literal notranslate"><span class="pre">kern/entry.S</span></code>，实现了分发处理异常的过程，在异常的分发小节有所详述，这里不再赘述。<br />
下面将对 Lab3 中的代码进行详细的分析：</p>
<ol class="arabic">
<li><p>env_run<br />
(1). 将正在执行的进程（如果有）的现场保存到对应的进程控制块中。<br />
(2). 选择一个可以运行的进程，恢复该进程上次被挂起时候的现场。这个过程主要通过 <code class="docutils literal notranslate"><span class="pre">env_pop_tf</span></code> 来完成，而 <code class="docutils literal notranslate"><span class="pre">env_pop_tf</span></code> 调用了 <code class="docutils literal notranslate"><span class="pre">ret_from_exception</span></code> 来完成从异常返回的过程。<code class="docutils literal notranslate"><span class="pre">env_pop_tf</span></code> 函数的部分内容如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LEAF</span><span class="p">(</span><span class="n">env_pop_tf</span><span class="p">)</span>
<span class="n">csrwr</span>   <span class="n">a1</span><span class="p">,</span> <span class="n">csr_asid</span>
<span class="n">move</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">a0</span>
<span class="n">RESET_KCLOCK</span>
<span class="n">b</span>       <span class="n">ret_from_exception</span>
<span class="n">END</span><span class="p">(</span><span class="n">env_pop_tf</span><span class="p">)</span>
</pre></div>
</div>
<p>我们在 <code class="docutils literal notranslate"><span class="pre">env.c</span></code> 中将进程控制块的 <code class="docutils literal notranslate"><span class="pre">env_tf.crmd</span></code> 初始化为 <code class="docutils literal notranslate"><span class="pre">CRMD_IE</span> <span class="pre">|</span> <span class="pre">CRMD_PLV</span></code>。这样设置是为了让 <code class="docutils literal notranslate"><span class="pre">la64</span></code> 可以正常响应时钟中断，从而可以在时钟中断发生时，由异常分发程序调用 <code class="docutils literal notranslate"><span class="pre">handle_int</span></code> 函数，经过 <code class="docutils literal notranslate"><span class="pre">timer_irq</span></code>、<code class="docutils literal notranslate"><span class="pre">schedule</span></code>、<code class="docutils literal notranslate"><span class="pre">env_run</span></code>来完成进程调度。</p>
</li>
<li><p>ret_from_exception<br />
从名字中就可以看出，这个函数作用是用例外返回，其具体实现如下：</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ret_from_exception</span><span class="p">:</span>
	<span class="n">RESTORE_SOME</span>
	<span class="n">ld</span><span class="o">.</span><span class="n">d</span>    <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">TF_REG3</span> <span class="o">/*</span> <span class="n">Deallocate</span> <span class="n">stack</span> <span class="o">*/</span>
	<span class="n">ertn</span>
</pre></div>
</div>
<p>首先是将保存到内核初始化栈上的中断现场恢复到对应的寄存器中，然后是恢复栈指针，将不同进程对应的栈指针加载到使用的栈指针中，最后是调用 <code class="docutils literal notranslate"><span class="pre">ertn</span></code> 指令，从例外处理返回。<br />
3. ertn<br />
<code class="docutils literal notranslate"><span class="pre">ERTN</span></code> 指令用于从例外处理返回。<br />
如果所处理的例外是 <code class="docutils literal notranslate"><span class="pre">Debug</span></code> 例外，将 <code class="docutils literal notranslate"><span class="pre">CSR.DBG</span></code> 中的 DS 位清0，同时跳转到 <code class="docutils literal notranslate"><span class="pre">CSR.DERA</span></code> 所存放的地址处开始取指。<br />
如果所处理的例外是 <code class="docutils literal notranslate"><span class="pre">Debug</span></code> 例外之外的其它例外，将例外对应的 PPLV、PIE、PWE 等信息更新至 <code class="docutils literal notranslate"><span class="pre">CSR.CRMD</span></code> 中，同时跳转到例外所对应的返回地址处开始取指。<br />
如果所处理的例外是 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 类例外，例外对应的 PPLV、PIE 和 PWE 信息来自于 <code class="docutils literal notranslate"><span class="pre">CSR.MERRCTL</span></code>，例外对应的返回地址来自于 <code class="docutils literal notranslate"><span class="pre">CSR.MERRERA</span></code>。除此之外，<code class="docutils literal notranslate"><span class="pre">Error</span></code> 类例外还要将 <code class="docutils literal notranslate"><span class="pre">CSR.MERRCTL</span></code> 中的 PDA、PPG、PDCAF、PDCAM 信息更新到 <code class="docutils literal notranslate"><span class="pre">CSR.CRMD</span></code> 中。<br />
如果所处理的例外是 TLB 重填例外，例外对应的 PPLV、PIE 和 PWE 信息来自于 <code class="docutils literal notranslate"><span class="pre">CSR.TLBRSAVE</span></code>，例外对应的返回地址来自于 <code class="docutils literal notranslate"><span class="pre">CSR.TLBRERA</span></code>。除此之外，还要将 <code class="docutils literal notranslate"><span class="pre">CSR.CRMD</span></code> 中的 DA 位清0、PG 位置1。<br />
如果所处理的例外不是 <code class="docutils literal notranslate"><span class="pre">Debug</span></code> 例外、<code class="docutils literal notranslate"><span class="pre">Error</span></code> 类例外和 TLB 重填例外，那么例外对应的 PPLV、PIE 和 PWE 信息来自于 <code class="docutils literal notranslate"><span class="pre">CSR.PRMD</span></code>，例外对应的返回地址来自于 <code class="docutils literal notranslate"><span class="pre">CSR.ERA</span></code>。<br />
执行 <code class="docutils literal notranslate"><span class="pre">ERTN</span></code> 指令时，如果 <code class="docutils literal notranslate"><span class="pre">CSR.LLBCTL</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">KLO</span></code> 位不等于1，则将 <code class="docutils literal notranslate"><span class="pre">LLbit</span></code> 置0，否则 <code class="docutils literal notranslate"><span class="pre">LLbit</span></code> 不修改。</p>
</section>
<section id="id49">
<h2><span class="section-number">4.5. </span>实验正确结果<a class="headerlink" href="#id49" title="Link to this heading"></a></h2>
<p>执行 <code class="docutils literal notranslate"><span class="pre">CFLAGS=-DMOS_SCHED_MAX_TICKS=100</span> <span class="pre">make</span></code> 或 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=3_3</span></code> 构建内核，再执行 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">run</span></code>，显示如下信息即通过 Lab3 的测试：</p>
<img alt="lab3_3结果部分展示" class="bg-primary align-center" src="_images/lab3_3%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" />
</section>
</section>
<section id="fork">
<h1><span class="section-number">5. </span>实验四：系统调用与FORK<a class="headerlink" href="#fork" title="Link to this heading"></a></h1>
<section id="id50">
<h2><span class="section-number">5.1. </span>实验目的<a class="headerlink" href="#id50" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>掌握系统调用的概念及流程</p></li>
<li><p>实现进程间通信机制</p></li>
<li><p>实现 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 函数</p></li>
<li><p>掌握页写入异常的处理流程</p></li>
</ol>
<p>在用户态下，用户进程不能访问系统的内核空间，也就是说它一般不能存取内核使用的内存数据，也不能调用内核函数，这一点是由体系结构保证的。然而，用户进程在特定的场景下往往需要执行一些只能由内核完成的操作，如操作硬件、动态分配内存，以及与其他进程进行通信等。允许在内核态执行用户程序提供的代码显然是不安全的，因此操作系统设计了一系列内核空间中的函数，当用户进程需要进行这些操作时，会引发特定的异常以陷入内核态，由内核调用对应的函数，从而安全地为用户进程提供受限的系统级操作，我们把这种机制称为系统调用。<br />
在 <code class="docutils literal notranslate"><span class="pre">Lab4</span></code> 中，我们需要实现上述的系统调用机制，并在此基础上实现进程间通信（IPC）机制和一个重要的进程创建机制 <code class="docutils literal notranslate"><span class="pre">fork</span></code>。在 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 部分的实验中，我们会介绍一种被称为写时复制（COW）的特性，以及与其相关的页写入异常处理。</p>
</section>
<section id="system-call">
<h2><span class="section-number">5.2. </span>系统调用(System Call)<a class="headerlink" href="#system-call" title="Link to this heading"></a></h2>
<p>本节中，我们着重讨论系统调用的作用，并完成其实现。</p>
<section id="id51">
<h3><span class="section-number">5.2.1. </span>用户态与内核态<a class="headerlink" href="#id51" title="Link to this heading"></a></h3>
<p>在之前各个 Lab 的学习中，相信大家对用户态、用户空间、内核态等概念已经不陌生了。随着 ‘la64’ 操作系统功能的不断完善，我们也需要扩充实现完整的用户态机制，这就包括操作系统中用户进程与内核进行通信的关键机制—系统调用。<br />
我们首先回顾以下几组概念：</p>
<ol class="arabic simple">
<li><p>用户态和内核态（也称用户模式和内核模式）：它们是 CPU 运行的两种状态。根据 Lab3 的说明，在 loongarch 架构中，该状态由 <code class="docutils literal notranslate"><span class="pre">CRMD</span></code> 寄存器中 PLV 位的值标志。</p></li>
<li><p>用户空间和内核空间：它们是虚拟内存（进程的地址空间）中的两部分区域。根据 Lab2 的说明，la64 中的用户空间包括 kuseg，而内核空间主要包括 kseg1 。每个进程的用户空间通常通过页表映射到不同的物理页，而内核空间则直接映射到固定的物理页1以及外部硬件设备。CPU 在内核态下可以访问任何内存区域，对物理内存等硬件设备有完整的控制权，而在用户态下则只能访问用户空间。</p></li>
<li><p>（用户）进程和内核：进程是资源分配与调度的基本单位，拥有独立的地址空间，而内核负责管理系统资源和调度进程，使进程能够并发运行。与前两对概念不同，进程和内核并不是对立的存在，可以认为内核是存在于所有进程地址空间中的一段代码。</p></li>
</ol>
</section>
<section id="id52">
<h3><span class="section-number">5.2.2. </span>系统调用实例<a class="headerlink" href="#id52" title="Link to this heading"></a></h3>
<p>puts() 函数是 C 标准库中用于输出一个字符串的函数，我们以其在 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 下的执行过程为例，展示其完整的调用过程如下：</p>
<table class="docutils align-center" id="id90">
<caption><span class="caption-text">puts函数完整调用过程</span><a class="headerlink" href="#id90" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 9.1%" />
<col style="width: 90.9%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Step1</p></td>
<td><p>用户调用 puts 函数</p></td>
</tr>
<tr class="row-even"><td><p>Step2</p></td>
<td><p>在一系列的函数调用后，最终调用了 write 函数</p></td>
</tr>
<tr class="row-odd"><td><p>Step3</p></td>
<td><p>write 函数在寄存器中设置了对应的系统调用号以及相应的参数，并执行了 syscall 指令</p></td>
</tr>
<tr class="row-even"><td><p>Step4</p></td>
<td><p>进入内核态，内核中相应的函数或服务被执行</p></td>
</tr>
<tr class="row-odd"><td><p>Step5</p></td>
<td><p>回到用户态的 write 函数中，将结果从相关的寄存器中取回，并返回</p></td>
</tr>
<tr class="row-even"><td><p>Step6</p></td>
<td><p>再次经过一系列的返回过程后，回到了 puts函数中</p></td>
</tr>
<tr class="row-odd"><td><p>Step7</p></td>
<td><p>puts 函数返回</p></td>
</tr>
</tbody>
</table>
<p>在 <code class="docutils literal notranslate"><span class="pre">loongarch</span></code> 中，syscall 是一条用于执行系统调用的自陷指令，它使得进程陷入到内核的异常处理程序中，由内核根据系统调用时的上下文执行相应的内核函数，完成相应的功能，并最终返回到 syscall 的后一条指令。从以上步骤，我们可以看到：</p>
<ol class="arabic simple">
<li><p>存在一些只能由内核来完成的操作（如读写设备、创建进程、IO 等）。</p></li>
<li><p>C 标准库中一些函数的实现须依赖于操作系统（如我们所探究的 puts 函数）。</p></li>
<li><p>通过执行 syscall 指令，用户进程可以陷入到内核态，请求内核提供的服务。</p></li>
<li><p>通过系统调用陷入到内核态时，需要在用户态与内核态之间进行数据传递与保护。</p></li>
</ol>
<p>综合以上内容，我们可以知道，内核将自己所能够提供的服务以系统调用的方式提供给用户空间，以供用户程序完成一些特殊的系统级操作。由于用户程序只能将服务相关的参数交予操作系统由操作系统执行，这样就保证了所有的特殊操作受操作系统掌控，而这些操作实际执行时也将由内核进行重重检查，因此系统调用保证了系统的安全性。<br />
进一步，由于直接使用这些系统调用较为麻烦，于是产生了一系列用户空间的 API 定义，如 POSIX 和 C 标准库等，它们在系统调用的基础上，实现更多更高级的常用功能，使得用户在编写程序时不用再处理这些繁琐而复杂的底层操作，而是直接通过调用高层次的 API 就能实现各种功能。通过这样巧妙的层次划分，使得程序更为灵活，也具有了更好的可移植性。对于用户程序来说，只要自己所依赖的 API 不变，无论底层的系统调用如何变化，都不会对自己造成影响，更易于在不同的系统间移植。整个结构如下表所示。</p>
<table class="docutils align-center" id="id91">
<caption><span class="caption-text">API、系统调用层次结构</span><a class="headerlink" href="#id91" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 33.3%" />
<col style="width: 66.7%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>用户程序 User Program</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>应用程序编程接口 API</p></td>
<td><p>POSIX, CStandard Library, etc.</p></td>
</tr>
<tr class="row-odd"><td><p>系统调用</p></td>
<td><p>read, write, etc.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id53">
<h3><span class="section-number">5.2.3. </span>系统调用机制的实现<a class="headerlink" href="#id53" title="Link to this heading"></a></h3>
<p>发现了系统调用的本质之后，我们就要着手在我们的 la64 操作系统中实现一套系统调用机制了。为了使得后面的实现思路更清晰，这里我们先回顾一下 Lab3 里面中断异常处理的行为：</p>
<ol class="arabic simple">
<li><p>处理器跳转到异常分发代码处</p></li>
<li><p>进入异常分发程序，根据 ESTAT 寄存器值判断异常类型并跳转到对应的处理程序</p></li>
<li><p>处理异常，并返回</p></li>
</ol>
<p>大家一定还记得异常分发向量组中的8号异常，它就是我们的操作系统处理系统调用时的异常。我们观察已有代码并跟随用户态 <code class="docutils literal notranslate"><span class="pre">user/lib/debugf.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">debugf</span></code> 函数来学习其具体流程：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">debugf</span></code> 函数内部的逻辑可分为两部分，一部分负责将参数解析为字符串，一部分负责将字符串输出（debug_output 函数）</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">debug_output</span></code> 函数调用了用户空间的 <code class="docutils literal notranslate"><span class="pre">syscall_*</span></code> 函数</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">syscall_*</span></code> 函数调用了 <code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数，系统由此陷入内核态</p></li>
<li><p>内核态中将异常分发到 <code class="docutils literal notranslate"><span class="pre">handle_sys</span></code> 函数，将系统调用所需要的信息 (在此处是需要输出的字符串 s) 传递入内核</p></li>
<li><p>内核取得信息，执行对应的内核空间的系统调用函数（sys_*）</p></li>
<li><p>系统调用完成，并返回用户态，同时将返回值“传递”回用户态</p></li>
<li><p>从系统调用函数返回，回到用户程序 <code class="docutils literal notranslate"><span class="pre">debugf</span></code> 调用处</p></li>
</ol>
<p>按照如上流程阅读代码的过程中，相信你已经发现了系统调用的流程，如下图所示：</p>
<img alt="syscall过程流程图" class="bg-primary align-center" src="_images/syscall%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" />
<p>在用户空间的程序中，我们定义了许多的函数，以 <code class="docutils literal notranslate"><span class="pre">debugf</span></code> 函数为例，这一函数实际上并不是最接近内核的函数，它最后会调用一个名为 <code class="docutils literal notranslate"><span class="pre">syscall_print_cons</span></code> 的函数，这个函数在 <code class="docutils literal notranslate"><span class="pre">user/lib/syscall_lib.c</span></code> 中。<br />
下面我们来引入<strong>系统调用号</strong>。<br />
系统调用号的概念：</p>
<ol class="arabic simple">
<li><p>在我们的 la64 操作系统实验中，这些 syscall_* 的函数与内核中的系统调用函数（ sys_* 的函数）是一一对应的。<br />
(a) syscall_* 的函数是我们在用户空间中最接近的内核的函数，在用户态调用。<br />
(b) sys_* 的函数是内核中系统调用的具体实现部分，在内核态执行。</p></li>
<li><p>在所有 <code class="docutils literal notranslate"><span class="pre">syscall_*</span></code> 的函数的实现中，都调用了 <code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数的第一个参数是一个与调用名相似的宏。例：<code class="docutils literal notranslate"><span class="pre">SYS_print_cons</span></code>。</p></li>
<li><p>这个参数就是系统调用号，定义于 <code class="docutils literal notranslate"><span class="pre">include/syscall.h</span></code>。</p></li>
</ol>
<p>系统调用号的作用：<br />
类似于不同异常类型对应不同异常号，系统调用号是内核区分不同系统调用的唯一依据。<br />
<code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数的参数：<br />
<code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 一共有 6 个参数，除系统调用号之外 <code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数还有 5 个参数，这些参数是系统调用时需要传递给内核的参数，因为最多参数的系统调用所需要的参数数量（<code class="docutils literal notranslate"><span class="pre">syscall_mem_map</span></code> 函数需要 5 个参数）。<br />
进一步的问题是，这些参数究竟是如何从用户态传递入内核态的呢？这里就需要用 <code class="docutils literal notranslate"><span class="pre">loongarch</span></code> 的调用规范来说明了。这里引入<strong>栈帧</strong>。<br />
栈帧的概念：</p>
<ol class="arabic simple">
<li><p>在 <code class="docutils literal notranslate"><span class="pre">loongarch</span></code> 的调用规范中，进入函数体时会通过对栈指针做减法（压栈）的方式为该函数自身的局部变量、返回地址、调用函数的参数分配存储空间。</p></li>
<li><p>而在函数调用结束之后会对栈指针做加法（弹栈）来释放这部分空间。</p></li>
<li><p>这部分空间称为栈帧（stack frame）。</p></li>
</ol>
<p>栈帧的使用方法：</p>
<ol class="arabic simple">
<li><p>调用方：在自身栈帧的底部预留被调用函数的参数存储空间。</p></li>
<li><p>被调用方：从调用方的栈帧中读取参数。</p></li>
</ol>
<p>根据 <code class="docutils literal notranslate"><span class="pre">loongarch</span></code> 寄存器使用规范，让我们来学习一下栈帧的实现细节：</p>
<ol class="arabic simple">
<li><p>寄存器 $a0-$a3 用于存放函数调用的前四个参数。</p></li>
<li><p>其余的参数存放在栈中。<br />
(a) 但是前四个参数还需要在栈上预留空间，就像它们需要从栈上传递一样。</p></li>
</ol>
<p>一个在 <code class="docutils literal notranslate"><span class="pre">loongarch</span></code> 中的例子：</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数一共有 6 个参数。<br />
(a) 前 4 个参数会被 <code class="docutils literal notranslate"><span class="pre">syscall_*</span></code> 的函数分别存入 $a0-$a3 寄存器（寄存器传参的部分）<br />
同时栈帧底部保留 16 字节的空间（不要求存入参数的值）
(b) 后 2 个参数只会被存入在预留空间之上的 8 字节空间内（没有寄存器传参）</p></li>
<li><p>总共 24 字节的空间用于参数传递。</p></li>
<li><p>C 代码中的这些调用过程会由编译器自动编译为汇编代码。</p></li>
<li><p>而我们在内核中则需要显式地从保存的用户上下文中获取函数的参数值。</p></li>
</ol>
<p>当 <code class="docutils literal notranslate"><span class="pre">user/lib/syscall_lib.c</span></code> 中定义的用户包装函数 <code class="docutils literal notranslate"><span class="pre">syscall_*</span></code> 调用 <code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 时，根据以上的调用规范，需要传递给内核的系统调用号以及其他参数已经被合理安置。接下来我们只需要编写用户空间中的<code class="docutils literal notranslate"><span class="pre">msyscall</span></code> 函数：</p>
<ol class="arabic simple">
<li><p>这个叶函数没有局部变量。</p></li>
<li><p>也就是说这个函数不需要分配栈帧。</p></li>
<li><p>只需执行自陷指令 <code class="docutils literal notranslate"><span class="pre">syscall</span></code> 来陷入内核态并在处理结束后正常返回即可。</p></li>
<li><p>请注意，<code class="docutils literal notranslate"><span class="pre">syscall</span></code> 指令是不允许在延迟槽中使用的。</p></li>
</ol>
<p>在通过 <code class="docutils literal notranslate"><span class="pre">syscall</span></code> 指令陷入内核态后，处理器将 PC 寄存器指向一个内核中固定的异常处理入口。在异常向量表中，系统调用这一异常类型的处理入口为 <code class="docutils literal notranslate"><span class="pre">handle_sys</span></code> 函数，它是在 <code class="docutils literal notranslate"><span class="pre">kern/genex.S</span></code> 中定义的对 <code class="docutils literal notranslate"><span class="pre">do_syscall</span></code> 函数的包装，我们需要首先在 <code class="docutils literal notranslate"><span class="pre">kern/syscall_all.c</span></code> 中实现 <code class="docutils literal notranslate"><span class="pre">do_syscall</span></code> 函数。<br />
关于陷入内核态，有一些点需要注意，具体如下：</p>
<ol class="arabic simple">
<li><p>陷入内核态的操作并不是从一个函数跳转到了另一个函数，代码使用的栈指针 $sp 是内核空间中的栈指针。</p></li>
<li><p>系统从用户态切换到内核态后，内核首先需要将原用户进程的运行现场保存到内核空间。<br />
(a) 在 <code class="docutils literal notranslate"><span class="pre">kern/entry.S</span></code> 中通过 <code class="docutils literal notranslate"><span class="pre">SAVE_ALL</span></code> 宏完成。</p></li>
<li><p>随后的栈指针则指向保存的 <code class="docutils literal notranslate"><span class="pre">Trapframe</span></code>，因此我们正是借助这个保存的结构体来获取用户态中传递过来的值。<br />
(a) 例如：用户态下 $a0 寄存器的值保存在内核栈的 TF_REG4(sp) 处。</p></li>
<li><p>当内核在 <code class="docutils literal notranslate"><span class="pre">handle_</span></code> 开头的包装函数中调用实际进行异常处理的 C 函数时，这个栈指针将作为参数传递给这个 C 函数。</p></li>
<li><p>因此我们可以在 C 语言中通过这个 <code class="docutils literal notranslate"><span class="pre">structTrapframe</span> <span class="pre">*</span></code> 来获取用户态现场中的参数。</p></li>
</ol>
<p>建议大家去阅读 <code class="docutils literal notranslate"><span class="pre">kern/syscall_all.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">do_syscall</span></code> 函数，详细理解内核部分的系统调用机制是如何工作的。<br />
做完这一步，整个系统调用的机制已经可以正常工作，接下来我们要来实现几个具体的系统调用。</p>
</section>
<section id="id54">
<h3><span class="section-number">5.2.4. </span>基础系统调用函数<a class="headerlink" href="#id54" title="Link to this heading"></a></h3>
<p>在了解系统调用机制后，接下来我们实现几个系统调用。<code class="docutils literal notranslate"><span class="pre">kern/syscall_all.c</span></code> 中定义了一系列系统调用，它们就是 <code class="docutils literal notranslate"><span class="pre">loongarch</span></code> 系统的基础系统调用，后续的 IPC 与 fork 机制都以这些系统调用作为支撑。<br />
<code class="docutils literal notranslate"><span class="pre">sys_mem_alloc</span></code> 函数：</p>
<ol class="arabic simple">
<li><p>这个函数的主要功能是分配内存。<br />
(a) 通过这个系统调用，用户程序可以给该程序所允许的虚拟内存空间显式地分配实际的物理内存。<br />
(b) 对于我们程序员的视角而言，是我们编写的程序在内存中申请了一片空间。<br />
(c) 对于操作系统内核来说，是一个进程请求将其运行空间中的某段地址与实际物理内存进行映射。<br />
i. 此处请同学们回顾进程虚拟页面映射机制、物理内存申请机制。<br />
ii. 我们将通过 <code class="docutils literal notranslate"><span class="pre">page_alloc</span></code>，<code class="docutils literal notranslate"><span class="pre">page_insert</span></code> 来实现内存分配和映射页面。<br />
iii. 完成时请注意检查虚拟地址的合法性。<br />
iv. 向系统调用传入的虚拟地址应当是有效的用户地址，否则不进行内存分配操作，返回错误代码 -E_INVAL。<br />
(d) 从而可以通过该虚拟页面来对物理内存进行存取访问。</p></li>
<li><p>接受一个进程的标识符（envid）作为参数，来确定发出请求的进程。</p></li>
<li><p>通过调用 <code class="docutils literal notranslate"><span class="pre">envid2env</span></code> 函数获得对应的进程控制块。</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">sys_mem_map</span></code> 函数：</p>
<ol class="arabic simple">
<li><p>这个函数的作用是将源进程地址空间中的相应内存映射到目标进程的相应地址空间的相应虚拟内存中去。<br />
(a) 此时两者共享一页物理内存。</p></li>
<li><p>这个函数有如下操作逻辑。<br />
(a) 找到需要操作的两个进程。<br />
(b) 获取源进程的虚拟页面对应的实际物理页面。<br />
(c) 将该物理页面与目标进程的相应地址完成映射。<br />
(d) 完成时请注意检查虚拟地址的合法性。<br />
i. 传入的虚拟地址应当是有效的用户地址。<br />
ii. 否则不进行页面映射操作，返回错误代码 -E_INVAL，表示传入非法（Invaild）用户地址。</p></li>
</ol>
<p>关于内存还有一个函数：<code class="docutils literal notranslate"><span class="pre">sys_mem_unmap</span></code>，这个系统调用的功能是解除某个进程地址空间虚拟内存和物理内存之间的映射关系。用到的函数：page_remove。<br />
除了与内存相关的函数外，另外一个常用的系统调用函数是 <code class="docutils literal notranslate"><span class="pre">sys_yield</span></code>。这个函数的功能是实现用户进程对 CPU 的放弃，从而调度其他的进程。可以利用我们之前已经编写好的函数 <code class="docutils literal notranslate"><span class="pre">schedule</span></code>。<br />
至此，我们能够进一步理解进程与内核间的关系并非对立：在内核处理进程发起的系统调用时，我们并没有切换地址空间（页目录地址），也不需要将进程上下文（Trapframe）保存到进程控制块中，只是切换到内核态下，执行了一些内核代码。可以说，处理系统调用时的内核仍然是代表当前进程的，这也是系统调用、TLB缺失等同步异常与时钟中断等异步异常的本质区别，<br />
实现系统调用后，我们已经可以编写并运行用户程序，利用系统调用让用户程序在控制台上输出文本了。</p>
</section>
</section>
<section id="ipc">
<h2><span class="section-number">5.3. </span>进程间通信机制(IPC)<a class="headerlink" href="#ipc" title="Link to this heading"></a></h2>
<p>进程间通信机制 (IPC) 是微内核最重要的机制之一。<br />
IPC 机制的实现远远没有我们想象得那样神秘，特别是在我们这个被简化了的 la64 操作系统中。IPC 机制的实现使得我们系统中的进程之间拥有了相互传递消息的能力，为后续实现 fork、文件系统服务、管道和 shell 均有着极大的帮助。根据之前的讨论，我们能够确定的是:</p>
<ul class="simple">
<li><p>IPC 的目的是使两个进程之间可以通信</p></li>
<li><p>IPC 需要通过系统调用来实现</p></li>
<li><p>IPC 还与进程的数据、页面等信息有关</p></li>
</ul>
<p>所谓通信，最直观的一种理解就是交换数据。假如我们能够将让一个进程有能力将数据传递给另一个进程，那么进程之间自然具有了相互通信的能力。由于这些进程的地址空间之间是相互独立的，要想传递数据，我们就需要想办法把一个地址空间中的东西传给另一个地址空间。<br />
我们知道，所有的进程都共享同一个内核空间（主要为kseg0）。因此，想要在不同空间之间交换数据，我们就可以借助于内核空间来实现。发送方进程可以将数据以系统调用的形式存放在进程控制块中，接收方进程同样以系统调用的方式在进程控制块中找到对应的数据，读取并返回.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">Env</span> <span class="p">{</span>
	<span class="n">u_long</span> <span class="n">env_ipc_value</span><span class="p">;</span>   <span class="o">//</span> <span class="n">the</span> <span class="n">value</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">us</span>
	<span class="n">u_long</span> <span class="n">env_ipc_from</span><span class="p">;</span>    <span class="o">//</span> <span class="n">envid</span> <span class="n">of</span> <span class="n">the</span> <span class="n">sender</span>
	<span class="n">u_long</span> <span class="n">env_ipc_recving</span><span class="p">;</span> <span class="o">//</span> <span class="n">whether</span> <span class="n">this</span> <span class="n">env</span> <span class="ow">is</span> <span class="n">blocked</span> <span class="n">receiving</span>
	<span class="n">u_long</span> <span class="n">env_ipc_dstva</span><span class="p">;</span>   <span class="o">//</span> <span class="n">va</span> <span class="n">at</span> <span class="n">which</span> <span class="n">the</span> <span class="n">received</span> <span class="n">page</span> <span class="n">should</span> <span class="n">be</span> <span class="n">mapped</span>
	<span class="n">u_long</span> <span class="n">env_ipc_perm</span><span class="p">;</span>    <span class="o">//</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">the</span> <span class="n">received</span> <span class="n">page</span> <span class="n">should</span> <span class="n">be</span> <span class="n">mapped</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在进程控制块中我们看到了我们想要的内容：</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 75.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>env_ipc_value</p></td>
<td><p>进程传递的具体数值</p></td>
</tr>
<tr class="row-even"><td><p>env_ipc_from</p></td>
<td><p>发送方的进程ID</p></td>
</tr>
<tr class="row-odd"><td><p>env_ipc_recving</p></td>
<td><p>1：等待接受数据中； 0：不可接受数据</p></td>
</tr>
<tr class="row-even"><td><p>env_ipc_dstva</p></td>
<td><p>接收到的页面需要与自身的哪个虚拟页面完成映射</p></td>
</tr>
<tr class="row-odd"><td><p>env_ipc_perm</p></td>
<td><p>传递的页面的权限位设置</p></td>
</tr>
</tbody>
</table>
<p>知道了这些，我们就不难实现 IPC 机制了。请结合下方讲解完成学习：<br />
<strong>sys_ipc_recv(u_int dstva)</strong> 函数用于接受消息。在该函数中：</p>
<ol class="arabic simple">
<li><p>首先要将自身的 <code class="docutils literal notranslate"><span class="pre">env_ipc_recving</span></code> 设置为 1，表明该进程准备接受发送方的消息</p></li>
<li><p>之后给 <code class="docutils literal notranslate"><span class="pre">env_ipc_dstva</span></code> 赋值，表明自己要将接受到的页面与 <code class="docutils literal notranslate"><span class="pre">dstva</span></code> 完成映射</p></li>
<li><p>阻塞当前进程，即把当前进程的状态置为不可运行（ENV_NOT_RUNNABLE）</p></li>
<li><p>最后放弃 CPU（调用相关函数重新进行调度），等待发送方将数据发送过来</p></li>
</ol>
<p><strong>sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)</strong> 函数用于发送消息：</p>
<ol class="arabic simple">
<li><p>根据 envid 找到相应进程，如果指定进程为可接收状态(考虑 <code class="docutils literal notranslate"><span class="pre">env_ipc_recving</span></code>)，则发送成功</p></li>
<li><p>否则，函数返回 <code class="docutils literal notranslate"><span class="pre">-E_IPC_NOT_RECV</span></code>，表示目标进程未处于接受状态</p></li>
<li><p>清除接收进程的接收状态，将相应数据填入进程控制块，传递物理页面的映射关系</p></li>
<li><p>修改进程控制块中的进程状态，使接受数据的进程可继续运行(ENV_RUNNABLE)</p></li>
</ol>
<p>建议大家仔细阅读 IPC 相关函数，把执行过程中的内核态用户态状态跳转，以及数据传输等等地方搞清楚，加深对系统调用的理解。<br />
值得一提的是，由于在我们的用户程序中，会大量使用 srcva 为 0 的调用来表示只传value 值，而不需要传递物理页面，换句话说，当 srcva 不为 0 时，我们才建立两个进程的页面映射关系。因此在学习相关函数时也需要注意此种情况。</p>
</section>
<section id="id55">
<h2><span class="section-number">5.4. </span>Fork<a class="headerlink" href="#id55" title="Link to this heading"></a></h2>
<p>在 Lab3 我们曾提到过，内核通过 env_create 函数创建一个进程。但如果要让一个进程创建一个进程，我们就需要基于系统调用，引入新的 fork 机制了。</p>
<section id="id56">
<h3><span class="section-number">5.4.1. </span>初窥 fork<a class="headerlink" href="#id56" title="Link to this heading"></a></h3>
<p>fork 函数简介：</p>
<ol class="arabic simple">
<li><p>fork 这个函数名有如下内涵。<br />
(a) 直接的翻译是叉子的意思，而在操作系统中是表示分叉的意思。<br />
(b) 就好像一条河流动着，遇到一个分叉口，分成两条河一样。<br />
(c) fork 就是那个分叉口。</p></li>
<li><p>一个进程在调用 <code class="docutils literal notranslate"><span class="pre">fork()</span></code> 函数后，将从此分叉成为两个进程运行。<br />
(a) 其中新产生的进程称为原进程的子进程。<br />
i. 子进程开始运行时的大部分上下文状态与原进程相同,包括程序和 fork 运行时的现场（包括通用寄存器和程序计数器PC等）<br />
ii. 在子进程中，fork() 调用的返回值为0。<br />
(b) 其中旧的进程称为子进程的父进程。<br />
i. 在父进程中，fork() 调用的返回值为子进程的 env_id。<br />
+ env_id 一定大于0。<br />
+ fork 失败的情况下，子进程不会被创建，且父进程将得到小于0的返回值。</p></li>
</ol>
<p>fork 在父子进程中产生不同返回值这一特性，让我们能够在代码中调用 fork 后判断当前在父进程还是子进程中，以执行不同的后续逻辑，也使父进程能够与子进程进行通信。<br />
你可能会想，fork 执行完为什么不直接生成一个空白的进程块，生成一个几乎和父进程一模一样的子进程有什么用呢？事实上，fork 是 Linux 操作系统中创建新进程最主要的方式。相比独立开始运行的两个进程，父子进程间的通信要方便的多。因为子进程中仍能读取原属于父进程的部分数据，父进程也可以根据 fork 返回的子进程 id，通过调用其他系统接口控制其行为。<br />
在 Linux 中，与 fork 经常一起使用的，是名为 exec 的一系列系统调用。它会使进程抛弃现有的程序和运行现场，执行一个新的程序。若在进程中调用 exec，进程的地址空间（以及在内存中持有的所有数据）都将被重置，新程序的二进制镜像将被加载到其代码段，从而让一个从头运行的全新进程取而代之。fork 的一种常见应用就被称作 fork-exec，指在 fork 出的子进程中调用 exec，从而在创建出的新进程中运行另一个程序。<br />
为了让读者对 fork 的认识不只是停留在理论层面，我们下面来做一个小实验，复制到您的 Linux 环境下运行一下吧。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">var</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">	</span><span class="kt">long</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">	</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Beforefork,var=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="w">	</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span>
<span class="w">	</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Afterfork, var=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">var</span><span class="p">);</span>
<span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">		</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">		</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;child got %ld, var = %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">		</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;parent got %ld, var = %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;, pid: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="w"> </span><span class="n">getpid</span><span class="p">());</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用 gcc fork_test.c &amp;&amp; ./a.out 运行一下，你得到的输出应该如下所示（pid 可能不同）</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Before</span> <span class="n">fork</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">After</span> <span class="n">fork</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">After</span> <span class="n">fork</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">parent</span> <span class="n">got</span> <span class="mi">16903</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pid</span><span class="p">:</span> <span class="mi">16902</span>
<span class="n">child</span> <span class="n">got</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pid</span><span class="p">:</span> <span class="mi">16903</span>
</pre></div>
</div>
<p>我们从这段简短的代码里可以获取到很多的信息，比如以下几点：</p>
<ul class="simple">
<li><p>fork 之前只有父进程存在。</p></li>
<li><p>fork 之后，父子进程同时开始执行 fork 之后的代码段。</p></li>
<li><p>fork 在不同的进程中返回值不一样，在子进程中返回值为 0，在父进程中返回值不为 0，而为子进程的 pid（Linux 中进程专属的 id，类似于 la64 中的 envid）。</p></li>
<li><p>父进程和子进程虽然很多信息相同，但他们的进程控制块是不同的。<br />
从上面的小实验我们也能看出来，子进程实际上就是按父进程的代码段等内存数据，以及进程上下文等状态作为模板而雕琢出来的。但即使如此，父子进程也还是有很多不同的地方。<br />
我们简要概括一下整个 fork 实现过程中需要仔细阅读的文件，包括：</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kern/syscall_all.c</span></code>：<code class="docutils literal notranslate"><span class="pre">sys_exofork</span></code> 函数，<code class="docutils literal notranslate"><span class="pre">sys_set_env_status</span></code> 函数，<code class="docutils literal notranslate"><span class="pre">sys_set_tlb_mod_entry</span></code> 函数是我们这次需要完成的函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kern/tlbex.c</span></code>：<code class="docutils literal notranslate"><span class="pre">do_tlb_mod</span></code> 函数负责完成写时复制处理前的相关设置，也是我们这次需要完成的函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user/lib/fork.c</span></code>：fork 函数是我们这次实验的重点函数，我们将分多个步骤来学习这个函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user/lib/fork.c</span></code>：cow_entry 函数是写时复制处理的函数，也是内核会从 do_tlb_mod 返回到的函数，负责对带有 PTE_COW 标志的页面进行处理，是我们这次需要完成的主要函数之一。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user/lib/fork.c</span></code>：duppage 函数是父进程对子进程页面空间进行映射以及相关标志设置的函数，是我们这次需要完成的主要函数之一。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user/lib/entry.S</span></code>：用户进程的入口，是我们这次需要了解的函数之一。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">user/lib/libos.c</span></code>：用户进程入口的 C 语言部分，负责完成执行用户程序 main 前后的准备和清理工作，是我们这次需要了解的函数之一。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kern/genex.S</span></code>：该文件实现了 la64 的异常处理流程，虽然不是我们需要实现的重点，但是建议读者认真阅读，理解中断处理的流程。</p></li>
</ul>
</section>
<section id="id57">
<h3><span class="section-number">5.4.2. </span>写时复制机制<a class="headerlink" href="#id57" title="Link to this heading"></a></h3>
<p>前文中，我们知道了在调用 fork 后，子进程会继承父进程地址空间中的代码段和数据段等内容。由于在 fork 后，父子进程将成为相互独立的两个进程，因此两个进程对于其内存的修改应该是互不影响的。<br />
如果我们在 fork 时将父进程地址空间中的内容全部复制到新的物理页，将会消耗大量的物理内存。而这些物理内存中，如代码段部分，父子进程通常不会对其进行写入。对于这样的页面，我们希望能够避免对它们进行复制，从而可以节省物理内存。<br />
为了父子进程能够共用尽可能多的物理内存，我们希望引入一种写时复制（Copy-on-write，COW）机制：</p>
<ol class="arabic simple">
<li><p>在 fork 时，只需将地址空间中的所有可写页标记为写时复制页面。</p></li>
<li><p>根据标记，在父进程或子进程对写时复制页面进行写入时，能够产生一种异常。</p></li>
<li><p>操作系统处理异常如下。<br />
(a) 为当前进程试图写入的虚拟地址分配新的物理页面。<br />
(b) 新的页面复制原页面的内容。<br />
(c) 返回用户程序。</p></li>
<li><p>处理完成后即可对新分配的物理页面进行写入。</p></li>
<li><p>这种机制使得我们可以最大限度的节省物理内存，减少了不必要的复制。</p></li>
</ol>
<p>为了实现写时复制机制，我们需要借助硬件异常来实现。在 loongarch 中，当程序尝试写入的虚拟页对应的 TLB 项没有 PTE_D 标志时，会触发 TLBMod 异常，使系统陷入到内核中。由于对应的异常处理函数是由内核设置的，因此我们可以使用它来实现写时复制机制。<br />
我们可以将写时复制界面的 PTE_D 标志置为 0。当进程读这个页面时，不会出现问题。但当进程尝试写这个页面时，由于 PTE_D 为 0，所以会触发 TLB Mod 异常。此时，我们就可以在异常处理函数中，将虚拟页映射到一个新的物理页，然后将旧的物理页的内容复制到新的物理页中。这样，两个进程的虚拟页就会各自映射到不同的物理页了。之后进程再对这个虚拟页进行修改，就不会有任何问题了。<br />
同时，为了区分真正的“只读”页面和“写时复制”页面，我们需要利用 TLB 项中的之前没有使用过的标志位，引入新的标志位 PTE_COW，在 loongarch 中，也就是 PTE_W， 写位。在 TLBMod 的异常处理函数中，如果触发该异常的页面的 PTE_COW 为 1，我们就需要进行上述的写时复制处理，即分配一页新的物理页，将写时复制页面的内容拷贝到这一物理页，然后映射给尝试写入该页面的进程。<br />
在我们的 la64 操作系统实验中，进程调用 fork 时，需要对其所有的可写入的内存页面，设置页表项标志位 PTE_COW 并取消可写位 PTE_D，以实现写时复制保护。在这样的保护下，用户程序可以在逻辑上认为 fork 时父进程中内存的状态被完整复制到了子进程中，此后父子进程可以独立操作各自的内存。</p>
</section>
<section id="id58">
<h3><span class="section-number">5.4.3. </span>fork 的返回值<a class="headerlink" href="#id58" title="Link to this heading"></a></h3>
<p>在我们的 la64 操作系统实验中，需要强调的一点是我们实现的 fork 是一个用户态函数，fork 函数中需要若干个原子的系统调用来完成所期望的功能。其中最核心的一个系统调用就是新进程的创建 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code>。<br />
在 fork 的实现中，我们是通过判断 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 的返回值来决定 fork 的返回值以及后续动作，所以会有类似这样结构的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">envid</span> <span class="o">=</span> <span class="n">syscall_exofork</span><span class="p">();</span>  
<span class="k">if</span> <span class="p">(</span><span class="n">envid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">//</span> <span class="n">子进程</span>
	<span class="o">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="o">//</span> <span class="n">父进程</span>
	<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>既然 fork 的目的是使得父子进程处于几乎相同的运行状态，我们可以认为在返回用户态时，父子进程应该经历了同样的恢复运行现场的过程，只不过对于父进程是从系统调用中返回时恢复现场，而对于子进程则是在进程被调度时恢复现场。在现场恢复后，父子进程都会从内核返回到 msyscall 函数中，而它们的现场中存储的返回值（即 $v0 寄存器的值）是不同的。这一返回值随后再被返回到 syscall_exofork 和 fork 函数，使 fork 函数也能区分两者。<br />
为了实现这一特性，你可能需要先学习 sys_exofork 的几个任务，在它分配一个新的进程控制块后，还需要用一些当前进程的信息作为模版来填充这个控制块：<br />
<strong>运行现场</strong> 要复制一份当前进程的运行现场（进程上下文） Trapframe 到子进程的进程控制块中。<br />
<strong>返回值有关</strong> 这个系统调用本身是需要一个返回值的，我们希望系统调用在内核态返回的 envid 只传递给父进程，对于子进程，则需要将其现场中的 v0 寄存器修改为 0。<br />
<strong>进程状态</strong> 我们当然不能让子进程在父进程的 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 返回后就直接被调度，因为这时候它还没有做好充分的准备，所以我们需要将它的状态设为 ENV_NOT_RUNNABLE 且避免它被加入调度队列。<br />
在解决完返回值的问题之后，父与子就能够分别各自从 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 中返回。</p>
</section>
<section id="id59">
<h3><span class="section-number">5.4.4. </span>地址空间的准备<a class="headerlink" href="#id59" title="Link to this heading"></a></h3>
<p>la64 允许进程访问自身的进程控制块，而在 <code class="docutils literal notranslate"><span class="pre">user/lib/libos.c</span></code> 的实现中，用户程序在运行时入口会将一个用户空间中的指针变量 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Env</span> <span class="pre">*env</span></code> 指向当前进程的控制块。对于 fork 后的子进程，它具有了一个与父亲不同的进程控制块，因此在子进程第一次被调度的时候（当然这时还是在 fork 函数中）需要对 env 指针进行更新，使其仍指向当前进程的控制块。这一更新过程与运行时入口对 env 指针的初始化过程相同，具体步骤如下：</p>
<ol class="arabic simple">
<li><p>通过一个系统调用来取得自己的 envid，因为对于子进程而言 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 返回的是一个 0 值。</p></li>
<li><p>根据获得的 envid，计算对应的进程控制块的下标，将对应的进程控制块的指针赋给 env。</p></li>
</ol>
<p>此外，父进程还需要将地址空间中需要与子进程共享的页面映射给子进程，这需要我们遍历父进程的大部分用户空间页，并使用将要实现的 duppage 函数来完成这一过程。duppage 时，对于可以写入的页面的页表项，在父进程和子进程都需要加上 PTE_COW 标志位，同时取消 PTE_D 标志位，以实现写时复制保护。<br />
在 duppage 函数中，唯一需要强调的一点是，要对具有不同权限位的页使用不同的方式进行处理。学习时需要注意这几种情况：<br />
<strong>只读页面</strong> 对于不具有 PTE_D 权限位的页面，按照相同权限（只读）映射给子进程即可。<br />
<strong>写时复制页面</strong>  即具有 PTE_COW 权限位的页面。这类页面是之前的 fork 时 duppage 的结果，且在本次 fork 前必然未被写入过。<br />
<strong>共享页面</strong>  即具有 PTE_LIBRARY 权限位的页面。这类页面需要保持共享可写的状态，即在父子进程中映射到相同的物理页，使对其进行修改的结果相互可见。在文件系统部分的实验中，我们会使用到这样的页面。
<strong>可写页面</strong>  即具有 PTE_D 权限位，且不符合以上特殊情况的页面。这类页面需要在父进程和子进程的页表项中都使用 PTE_COW 权限位进行保护。<br />
在完成写时复制的保护机制后，还不能让子进程处于能被调度的状态，因为作为父亲它还有其他的责任——为写时复制特性的页写入异常处理做好准备。</p>
</section>
<section id="id60">
<h3><span class="section-number">5.4.5. </span>页写入异常<a class="headerlink" href="#id60" title="Link to this heading"></a></h3>
<p>内核在捕获到一个常规的缺页中断（TLB 缺失异常）时会陷入异常，跳转到异常处理函数 <code class="docutils literal notranslate"><span class="pre">handle_tlb</span></code> 中，这一汇编函数的实现在 <code class="docutils literal notranslate"><span class="pre">kern/genex.S</span></code> 中，通过调用 <code class="docutils literal notranslate"><span class="pre">do_tlb_refill</span></code> 函数，在页表中进行查找，将物理地址填入 TLB 并返回到用户程序中的异常地址，再次执行访存指令。<br />
前文中我们提到了写时复制（COW）特性，这种特性也是依赖于异常处理的。当用户程序写入一个在 TLB 中被标记为不可写入（无 PTE_D）的页面时，loongarch 会陷入页写入异常（TLBMod），我们在异常向量组中为其注册了一个处理函数 <code class="docutils literal notranslate"><span class="pre">handle_mod</span></code>，这一函数会跳转到 <code class="docutils literal notranslate"><span class="pre">kern/tlbex.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">do_tlb_mod</span></code> 函数中，这个函数正是处理页写入异常的内核函数。对于需要写时复制（COW）的页面，我们只需取消其 <code class="docutils literal notranslate"><span class="pre">PTE_D</span></code> 标记，即可在它们被写入时触发 <code class="docutils literal notranslate"><span class="pre">do_tlb_mod</span></code> 中的处理逻辑。<br />
你可能会发现，<code class="docutils literal notranslate"><span class="pre">do_tlb_mod</span></code> 函数似乎并没有进行页面复制等 COW 的处理操作。事实上，我们的 la64 操作系统按照微内核的设计理念，尽可能地将功能实现在用户空间中，其中也包括了页写入异常的处理，因此主要的处理过程是在用户态下完成的。<br />
如果需要在用户态下完成页写入异常的处理，是不能直接使用正常情况下的用户栈的（因为发生页写入异常的也可能是正常栈的页面），所以用户进程就需要一个单独的栈来执行处理程序，我们把这个栈称作异常处理栈，它的栈顶对应的是内存布局中的 <code class="docutils literal notranslate"><span class="pre">UXSTACKTOP</span></code>。此外，内核还需要知晓进程自身的处理函数所在地址，它的地址存在于进程控制块的 <code class="docutils literal notranslate"><span class="pre">env_user_tlb_mod_entry</span></code> 域中，这个地址也需要事先由父进程通过系统调用设置。<br />
因此，概括一下上述内容，在我们的 la64 操作系统中，处理页写入异常的大致流程可以概括为：</p>
<ol class="arabic simple">
<li><p>用户进程触发页写入异常，陷入到内核中的 <code class="docutils literal notranslate"><span class="pre">handle_mod</span></code>，再跳转到 <code class="docutils literal notranslate"><span class="pre">do_tlb_mod</span></code> 函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">do_tlb_mod</span></code> 函数负责将当前现场保存在异常处理栈中，并设置 a0 和 ERA 寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场（Trapframe）为参数，跳转到 <code class="docutils literal notranslate"><span class="pre">env_user_tlb_mod_entry</span></code> 域存储的用户异常处理函数的地址。</p></li>
<li><p>从异常恢复到用户态，跳转到用户异常处理函数中，由用户程序完成写时复制等自定义处理。</p></li>
</ol>
<p>处理 COW 时，我们需要注册的页写入异常用户处理函数是 fork.c 中定义的 cow_entry 函数。这个函数进行写时复制处理之后，使用系统调用 syscall_set_trapframe 恢复事先保存好的现场，其中也包括 sp 和 PC 寄存器的值，使得用户程序恢复执行。<br />
让我们回到 fork 函数，在调用 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 之前，我们需要使用 <code class="docutils literal notranslate"><span class="pre">syscall_set_tlb_mod_entry</span></code> 函数来注册自身的页写入异常处理函数，也就是我们上文提到的 <code class="docutils literal notranslate"><span class="pre">env_user_tlb_mod_entry</span></code> 域指向的用户处理函数。这里需要通过系统调用告知内核自身的处理程序是 <code class="docutils literal notranslate"><span class="pre">cow_entry</span></code>。你还需要完成内核中的系统调用处理函数 <code class="docutils literal notranslate"><span class="pre">sys_set_tlb_mod_entry</span></code>，将进程控制块的 <code class="docutils literal notranslate"><span class="pre">env_user_tlb_mod_entry</span></code> 域设为传入的参数。<br />
我们现在知道了页写入异常处理时会返回到用户空间的 <code class="docutils literal notranslate"><span class="pre">cow_entry</span></code> 函数，我们再来看这个函数会做些什么。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span> <span class="n">cow_entry</span><span class="p">(</span><span class="n">struct</span> <span class="n">Trapframe</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">u_int</span> <span class="n">va</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">cp0_badvaddr</span><span class="p">;</span>
	<span class="o">//</span> <span class="o">...</span>
	<span class="nb">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">syscall_set_trapframe</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tf</span><span class="p">);</span>
	<span class="n">user_panic</span><span class="p">(</span><span class="s2">&quot;syscall_set_trapframe returned </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>从内核返回后，此时的第一个参数是由内核设置的，处于异常处理栈中，且指向一个由内核复制好的 Trapframe 结构体的底部。该函数从 Trapframe 中读取了 TF_BADV 字段的值，这个值也正是 CPU 设置的发生页写入异常的地址 va，我们可以根据这个地址进行写时复制处理。在函数的最后，使用系统调用 syscall_set_trapframe 恢复了保存的现场。<br />
说到这里，我们就要来学习 cow_entry 中真正进行处理的部分了。你需要学习以下这些任务相关的内容：</p>
<ol class="arabic simple">
<li><p>根据 vpt 中 va 所在页的页表项，判断其标志位是否包含 PTE_COW，是则进行下一步，否则调用 user_panic() 报错。</p></li>
<li><p>分配一个新的临时物理页到临时地址 UCOW，使用 memcpy 将 va 页的数据拷贝到刚刚分配的页中。</p></li>
<li><p>将发生页写入异常的地址 va 映射到临时页面上，注意设定好对应的页面标志位（即去除 PTE_COW 并恢复 PTE_D），然后解除临时地址 UCOW 的内存映射。</p></li>
</ol>
<p>父进程还需要使用 <code class="docutils literal notranslate"><span class="pre">syscall_set_tlb_mod_entry</span></code>，设置子进程的页写入异常处理函数为 cow_entry。最后，父进程通过系统调用 <code class="docutils literal notranslate"><span class="pre">syscall_set_env_status</span></code> 设置子进程为可以运行的状态。在内核中实现<code class="docutils literal notranslate"><span class="pre">sys_set_env_status</span></code> 函数时，不仅需要设置进程控制块的 <code class="docutils literal notranslate"><span class="pre">env_status</span></code> 域，还需要在 <code class="docutils literal notranslate"><span class="pre">env_status</span></code> 从 <code class="docutils literal notranslate"><span class="pre">ENV_NOT_RUNNABLE</span></code> 转换为 <code class="docutils literal notranslate"><span class="pre">ENV_RUNNABLE</span></code> 时将控制块加入到可调度进程的链表中，反之则从链表中移除。<br />
说到这里我们需要整理一下思路，fork 中父进程在 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 后还需要做的事情有：</p>
<ol class="arabic simple">
<li><p>遍历父进程地址空间，进行 duppage。</p></li>
<li><p>设置子进程的异常处理函数，确保页写入异常可以被正常处理。</p></li>
<li><p>设置子进程的 <code class="docutils literal notranslate"><span class="pre">env_status</span></code>，允许其被调度。</p></li>
</ol>
<p>最后再将子进程的 envid 返回，fork 函数就完成了。</p>
</section>
</section>
<section id="id61">
<h2><span class="section-number">5.5. </span>实验正确结果<a class="headerlink" href="#id61" title="Link to this heading"></a></h2>
<p>本次实验下有多个测试程序，最简单的单元测试是 <code class="docutils literal notranslate"><span class="pre">envid2env_check()</span></code>，在完成 <code class="docutils literal notranslate"><span class="pre">envid2env</span></code> 后，将 <code class="docutils literal notranslate"><span class="pre">envid2env_check()</span></code> 加入 <code class="docutils literal notranslate"><span class="pre">init/init.c</span></code> 即可测试，也可以使用 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=4_1</span></code>直接构建测试。其参考输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>envid2env()workwell!
</pre></div>
</div>
<p>用户态的第一个测试程序是 <code class="docutils literal notranslate"><span class="pre">user/tltest.c</span></code>，在系统调用部分完成后，将 <code class="docutils literal notranslate"><span class="pre">ENV_CREATE(user_tltest)</span></code> 加入 <code class="docutils literal notranslate"><span class="pre">init/init.c</span></code>，使用 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code>即可测试，参考输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Smashing</span> <span class="n">some</span> <span class="n">kernel</span> <span class="n">codes</span><span class="o">...</span>  
<span class="n">If</span> <span class="n">your</span> <span class="n">implementation</span> <span class="ow">is</span> <span class="n">correct</span><span class="p">,</span> <span class="n">you</span> <span class="n">may</span> <span class="n">see</span> <span class="n">unknown</span> <span class="n">exception</span> <span class="n">here</span><span class="p">:</span>
<span class="o">...</span>
<span class="n">panic</span> <span class="n">at</span> <span class="n">traps</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">24</span> <span class="p">(</span><span class="n">do_reserved</span><span class="p">):</span> <span class="n">Unknown</span> <span class="n">ExcCode</span> <span class="mi">5</span>
</pre></div>
</div>
<p>完成fork后，单独测试fork的程序是user/fktest.c，使用方法同上。其参考输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">this</span> <span class="ow">is</span> <span class="n">father</span><span class="p">:</span> <span class="n">a</span><span class="p">:</span><span class="mi">1</span>
<span class="n">this</span> <span class="ow">is</span> <span class="n">father</span><span class="p">:</span> <span class="n">a</span><span class="p">:</span><span class="mi">1</span>
<span class="n">this</span> <span class="ow">is</span> <span class="n">father</span><span class="p">:</span> <span class="n">a</span><span class="p">:</span><span class="mi">1</span>
<span class="o">...</span>
		<span class="n">this</span> <span class="ow">is</span> <span class="n">child</span> <span class="p">:</span><span class="n">a</span><span class="p">:</span><span class="mi">2</span>
		<span class="n">this</span> <span class="ow">is</span> <span class="n">child</span> <span class="p">:</span><span class="n">a</span><span class="p">:</span><span class="mi">2</span>
		<span class="n">this</span> <span class="ow">is</span> <span class="n">child</span> <span class="p">:</span><span class="n">a</span><span class="p">:</span><span class="mi">2</span>
<span class="o">...</span>
		<span class="n">this</span> <span class="ow">is</span> <span class="n">child2</span> <span class="p">:</span><span class="n">a</span><span class="p">:</span><span class="mi">3</span>
		<span class="n">this</span> <span class="ow">is</span> <span class="n">child2</span> <span class="p">:</span><span class="n">a</span><span class="p">:</span><span class="mi">3</span>
		<span class="n">this</span> <span class="ow">is</span> <span class="n">child2</span> <span class="p">:</span><span class="n">a</span><span class="p">:</span><span class="mi">3</span>
</pre></div>
</div>
<p>其中三种文本段应当交替出现且永不停止。<br />
另一个测试程序 <code class="docutils literal notranslate"><span class="pre">user/pingpong.c</span></code> 主要测试 fork 和进程间通信，参考输出如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">@@@@</span><span class="nd">@send</span> <span class="mi">0</span> <span class="kn">from</span><span class="w"> </span><span class="mi">800</span> <span class="n">to</span> <span class="mi">1001</span>
<span class="mi">1001</span> <span class="n">am</span> <span class="n">waiting</span><span class="o">.....</span>
<span class="mi">800</span> <span class="n">am</span> <span class="n">waiting</span><span class="o">.....</span>
<span class="mi">1001</span> <span class="n">got</span> <span class="mi">0</span> <span class="kn">from</span><span class="w"> </span><span class="mi">800</span>

<span class="o">@@@@</span><span class="nd">@send</span> <span class="mi">0</span> <span class="kn">from</span><span class="w"> </span><span class="mi">1001</span> <span class="n">to</span> <span class="mi">800</span>
<span class="mi">1001</span> <span class="n">am</span> <span class="n">waiting</span><span class="o">.....</span>
<span class="mi">800</span> <span class="n">got</span> <span class="mi">1</span> <span class="kn">from</span><span class="w"> </span><span class="mi">1001</span>
</pre></div>
</div>
</section>
</section>
<section id="id62">
<h1><span class="section-number">6. </span>实验五：文件系统<a class="headerlink" href="#id62" title="Link to this heading"></a></h1>
<section id="id63">
<h2><span class="section-number">6.1. </span>实验目的<a class="headerlink" href="#id63" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>了解文件系统的基本概念和作用。</p></li>
<li><p>了解普通磁盘的基本结构和读写方式。</p></li>
<li><p>了解实现设备驱动的方法。</p></li>
<li><p>掌握并实现文件系统服务的基本操作。</p></li>
<li><p>了解微内核的基本设计思想和结构。</p></li>
</ol>
<p>在之前的实验中，我们把所有的程序和数据都存放在内存中。然而内存空间的大小是有限的，而且内存中的数据存在易失性问题。因此有些数据必须保存在磁盘、光盘等外部存储设备上, 这些外部存储设备能够长期保存大量的数据，且便于将数据装载到不同进程的内存空间进行共享。为了便于管理和访问存放在外部存储设备上的数据，在操作系统中引入了文件系统。在文件系统中，文件是数据存储和访问的基本单位。对于用户而言，文件系统可以屏蔽访问外存数据的复杂性。</p>
</section>
<section id="id64">
<h2><span class="section-number">6.2. </span>文件系统概述<a class="headerlink" href="#id64" title="Link to this heading"></a></h2>
<p>计算机文件系统是一种存储和组织数据的方法，便于访问和查找数据。文件系统使用文件和树型目录的逻辑抽象屏蔽了底层硬盘和光盘等物理设备基于数据块进行存储和访问的复杂性。用户不必关心数据实际保存在硬盘（或者光盘）的哪个数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的哪个块是空闲的，硬盘上的存储空间管理（分配和释放）由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中即可。<br />
常见的文件系统通常基于硬盘和光盘等块存储设备，并维护文件在设备中的物理位置；而此外的某些文件系统仅仅是一种访问数据的接口，实际的数据在内存中或者通过网络协议（如NFS、SMB、FTP 等）提供。<br />
广义上，一切带标识的、在逻辑上有完整意义的字节序列都可以称为“文件”。文件系统将外部设备中的资源抽象为文件，从而可以统一管理外部设备，实现对数据的存储、组织、访问和修改等操作。在本实验中，我们拟实现一个精简的文件系统，其中需要对三种设备进行统一管理，即文件设备（file，即狭义的“文件”）、控制台（console）和管道（pipe）。其中，后两者将在下一个实验“管道与 Shell”中进行使用。</p>
<section id="id65">
<h3><span class="section-number">6.2.1. </span>文件系统的设计与实现<a class="headerlink" href="#id65" title="Link to this heading"></a></h3>
<p>在本次实验中，我们将要实现一个简单但结构完整的文件系统。整个文件系统包括以下几个部分：</p>
<ol class="arabic simple">
<li><p>外部存储设备驱动：通常，我们需要按一定顺序读写设备寄存器，来实现对外部设备的操作。为了将这种操作转化为具有通用、明确语义的接口，必须实现相应的驱动程序。在本部分，我们将实现IDE 磁盘的用户态驱动程序，该驱动程序将通过系统调用的方式陷入内核，对磁盘镜像进行读写操作。</p></li>
<li><p>文件系统结构：在本部分，我们会实现模拟磁盘的驱动程序以及磁盘上和操作系统中的文件系统结构，并实现文件系统操作的相关函数。在我们的操作系统中，fs目录下存放的是文件系统服务程序的代码；而 user/lib 目录中的 file.c、fd.c、fsipc.c 等文件则存放了文件系统的用户库，这部分代码会被一同链接到用户程序中，允许用户程序调用其中的函数来操作文件系统。文件系统服务进程和其他用户进程之间使用 Lab4 中实现的 IPC 机制进行通信。</p></li>
<li><p>文件系统的用户接口：在本部分，要求为用户提供接口和机制使得用户程序能够使用文件系统，这主要通过一个用户态的文件系统服务来实现。同时，我们将引入文件描述符等结构来抽象地表示一个进程所打开的文件，而不必关心文件实际的物理表示。</p></li>
</ol>
<p>整个文件系统所涉及的代码文件比较多, 此处我们概要介绍一些核心代码文件的主要功能，希望有助于理解文件系统实现的总体框架。这些代码实现在三个目录中：</p>
<ul class="simple">
<li><p>tools：目录中存放的是构建时辅助工具的代码。在之前的 Lab 中，我们实现了解析 ELF 文件的 readelf 工具; 本 Lab 中，我们将在其中实现 fsformat 工具，并借助它来创建磁盘镜像。请注意，tools 目录下的代码仅用于 la64 的构建，在宿主 Linux 环境（而非 loongarch 模拟器）中运行，也不会被编译进 la64 的内核、用户库或用户程序中。</p></li>
<li><p>fs：目录中存放的是文件系统服务进程的代码。我们在 fs.c 中实现文件系统的基本功能函数，在 ide.c 中通过系统调用与磁盘镜像进行交互。该进程的主干函数在 serv.c 中，通过 IPC 通信与用户进程 <code class="docutils literal notranslate"><span class="pre">user/lib/fsipc.c</span></code> 内的通信函数进行交互。</p></li>
<li><p>user/lib：目录下存放了用户程序的库函数。在本 Lab 中，该目录下的 fsipc.c 实现了与文件系统服务进程的交互，file.c 实现了文件系统的用户接口；fd.c 中实现了文件描述符，允许用户程序使用统一的接口，抽象地操作磁盘文件系统中的文件，以及控制台和管道等虚拟的文件。</p></li>
</ul>
<p>整个文件系统体现了 la64 的微内核设计，包括下面三个部分：</p>
<ol class="arabic simple">
<li><p>将传统操作系统的文件系统移出内核，使用用户态的文件系统服务程序以及一系列用户库来实现。即使它们崩溃，也不会影响到整个内核的稳定。其他用户进程通过进程间通信 (IPC) 来请求文件系统的相关服务。因此，在微内核中进程间通信 (IPC) 是一个十分重要的机制。</p></li>
<li><p>操作系统将一些内核数据暴露到用户空间，使得进程不需要切换到内核态就能访问。la64 将进程页表映射到用户空间，此处文件系统服务进程访问自身进程页表即可判断磁盘缓存中是否存在对应块。</p></li>
<li><p>将传统操作系统的设备驱动移出内核，作为用户程序来实现。微内核体现在，内核在此过程中仅提供读写设备物理地址的系统调用。</p></li>
</ol>
<p>接下来我们一一详细解读这些部分的实现。</p>
</section>
</section>
<section id="ide">
<h2><span class="section-number">6.3. </span>IDE 磁盘驱动<a class="headerlink" href="#ide" title="Link to this heading"></a></h2>
<p>为了在磁盘等外部设备上实现文件系统，我们必须为这些外部设备编写驱动程序。实际上，la64 已经在 <code class="docutils literal notranslate"><span class="pre">kern/machine.c</span></code> 中实现了一个简单的控制台驱动程序，其中在内核态下使用了内存映射 I/O（MMIO）技术，通过控制台实现了字符的输入输出。<br />
本次要实现的硬盘驱动程序与已经实现的串口驱动，都采用 MMIO 技术编写驱动，不同之处在于，我们需要驱动的物理设备— IDE 磁盘功能更加复杂，并且本次要编写的驱动程序完全运行在用户空间。<br />
下面我们首先介绍内存映射 I/O，之后再了解 IDE 磁盘的结构和操作，最后介绍磁盘驱动程序的编写。</p>
<section id="i-o-mmio">
<h3><span class="section-number">6.3.1. </span>内存映射 I/O (MMIO)<a class="headerlink" href="#i-o-mmio" title="Link to this heading"></a></h3>
<p>在“内存管理”实验中，我们已经了解了 loongarch 存储器地址映射的基本内容。几乎每一种外设都是通过读写设备上的寄存器来进行数据通信，外设寄存器也称为 I/O 端口，主要用来访问 I/O 设备。外设寄存器通常包括控制寄存器、状态寄存器和数据寄存器，这些寄存器被映射到指定的物理地址空间。例如，在 MALTA 中，console 设备被映射到 0x180003F8，IDE 控制器被映射到0x180001F0，等等。<br />
实验中使用的 loongarch 体系结构并没有复杂的 I/O 端口的概念，而是统一使用内存映射 I/O 的模型。在 loongarch 的内核地址空间中（kseg1段）实现了硬件级别的物理地址和内核虚拟地址的转换机制，其中，对kseg1 段地址的读写不经过MMU映射，且不使用高速缓存，这正是外部设备驱动所需要的。由于我们是在模拟器上运行操作系统，I/O 设备的物理地址是完全固定的，因此我们可以通过简单地读写某些固定的内核虚拟地址来实现驱动程序的功能。<br />
在之前的实验中，我们曾经使用 KADDR 宏把一个物理地址转换为 kseg1 段的内核虚拟地址，实际上是给物理地址加上 kseg1 的偏移值（即 0x9000000000000000）。在编写设备驱动的时候，我们需要将物理地址转换为kseg1 段的内核虚拟地址，也就是同样给物理地址加上 kseg1 的偏移值(0x9000000000000000)。<br />
以我们编写完成的串口设备驱动为例，MALTA 提供的 console 设备是一个典型的 NS16550 设备，其基地址为 0x180003F8，设备寄存器映射如图所示。</p>
<img alt="MALTA_NS16550_设备内存映射" class="bg-primary align-center" src="_images/MALTA_NS16550_%E8%AE%BE%E5%A4%87%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.png" />
<p>现在，我们通过往内存的(0x180003F8 + 0x9000000000000000) 地址写入字符，就能在 shell 中看到对应的输出。<br />
kern/machine.c 中的 printcharc 函数的实现如下所示：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">printcharc</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">KSEG1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">MALTA_SERIAL_DATA</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ch</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个函数首先通过 <code class="docutils literal notranslate"><span class="pre">KSEG1</span> <span class="pre">+</span> <span class="pre">MALTA_SERIAL_DATA</span></code> 定位到了字符需要被写入到的地址，为了对这个地址的数据进行操作需要将其强制转化为类型 char 的指针。注意，此处的类型 char 要使用 volatile 限定。因为对于 I/O 设备的操作，我们的预期是每次操作都直接与设备进行交互。如果不使用 volatile，编译器可能会对该地址的数据的访问做优化，导致对于 I/O 设备的地址的访问不直接与设备交互。例如，对于这个地址进行多次连续读取，编译器可能会优化为只读取一次，并复用这个结果，进而引发错误。转化为使用 volatile 修饰的指针之后，通过解引用，可以对这个地址的数据进行修改。<br />
而在本次实验中，我们需要编写的 IDE 磁盘驱动程序位于用户空间，用户态进程若是直接读写内核虚拟地址将会由处理器引发一个地址错误（ADEL/S）。所以对于设备的读写必须通过系统调用来实现。这里我们引入了 <code class="docutils literal notranslate"><span class="pre">sys_write_dev</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys_read_dev</span></code> 两个系统调用来实现设备的读写操作。这两个系统调用以用户虚拟地址、设备的物理地址和读写的长度（按字节计数），作为参数，在内核空间中完成 I/O 操作。</p>
</section>
<section id="id66">
<h3><span class="section-number">6.3.2. </span>IDE 磁盘<a class="headerlink" href="#id66" title="Link to this heading"></a></h3>
<p>在我们的实验中，MALTA 提供的“磁盘”是一个 <code class="docutils literal notranslate"><span class="pre">Intel</span> <span class="pre">PIIX4</span> <span class="pre">IDE</span></code> 控制器，其上连接 IDE 磁盘供操作系统使用。具体关于此 IDE 设备的信息，可以参考 Intel 82371AB PCI ISA IDEXcelerator (PIIX4)（第 192 页 9.2 节）。在此基础上，我们就可以实现 la64 的文件系统了。接下来，我们将了解一些读写 IDE 磁盘的基础知识。<br />
<strong>磁盘的物理结构</strong><br />
下面简单介绍与磁盘相关的基本知识，首先是几个基本概念：</p>
<ol class="arabic simple">
<li><p>扇区（sector）: 磁盘盘片被划分成很多扇形的区域，这些区域叫做扇区。扇区是磁盘执行读写操作的单位，一般是 512 字节。扇区的大小是一个磁盘的硬件属性。</p></li>
<li><p>磁道（track）: 盘片上以盘片中心为圆心，不同半径的同心圆。</p></li>
<li><p>柱面（cylinder）: 硬盘中，不同盘片相同半径的磁道所组成的圆柱面。</p></li>
<li><p>磁头（head）: 每个磁盘有两个面，每个面都有一个磁头。当对磁盘进行读写操作时，磁头在盘片上快速移动。</p></li>
</ol>
<p>典型磁盘的基本结构如下图所示：</p>
<img alt="磁盘结构示意图" class="bg-primary align-center" src="_images/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" />
<p><strong>IDE 磁盘操作</strong><br />
前文中我们提到过，扇区（sector）是磁盘读写的基本单位，MALTA 上的 PIIX4 也提供了对扇区进行操作的基本方法。通过读写 PIIX4 的特定寄存器，我们可以实现以扇区为最小单元的读写。MALTA 平台上的 PIIX4 磁盘控制器基地址为 0x180001F0，其 I/O 相关寄存器相对于该地址的偏移和对应的功能如下图所示。</p>
<img alt="PIIX4关键寄存器映射" class="bg-primary align-center" src="_images/PIIX4%E5%85%B3%E9%94%AE%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84.png" />
<p>在 la64 中，我们可以挂载两块 IDE 磁盘（磁盘编号为0和1），但实际上我们只使用到了磁盘编号为0的一块磁盘。<br />
对于磁盘寻址，我们可以按照柱面-磁头-扇区（Cylinder-Head-Sector，CHS）的方式来定位一个扇区。这种寻址方式符合磁盘的物理结构，但是显然三个参数导致了寻址的复杂性。在该模式下，PIIX4 I/O 的寄存器映射含义与上图中不完全相同，具体可以参考前文给出的文档。<br />
由于 CHS 模式下不方便进行寻址，因此在实验中我们采用逻辑块寻址（LogicalBlock Addressing，LBA）的方式来进行扇区寻址。在 LBA 模式下，IDE 设备将磁盘看作一个线性的字节序列，每个扇区都有一个唯一的编号，只需要设置目标扇区编号，就可以完成磁盘的寻址。在我们的实验中，扇区编号有 28 位，因此最多可以寻址 228 个扇区，即 128 GB 的磁盘空间。该模式下，磁盘操作参数和寄存器映射的关系如下图所示。</p>
<img alt="LBA模式下参数和寄存器映射关系图" class="bg-primary align-center" src="_images/LBA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8F%82%E6%95%B0%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" />
</section>
<section id="id67">
<h3><span class="section-number">6.3.3. </span>驱动程序编写<a class="headerlink" href="#id67" title="Link to this heading"></a></h3>
<p>通过对 <code class="docutils literal notranslate"><span class="pre">printcharc</span></code> 函数的实现的分析，我们已经掌握了 <code class="docutils literal notranslate"><span class="pre">I/O</span></code> 操作的基本方法，那么，读写 <code class="docutils literal notranslate"><span class="pre">IDE</span></code> 磁盘的相关代码也就不难理解了。<br />
当我们在磁盘的指定位置读取或写入一个扇区时，需要调用 <code class="docutils literal notranslate"><span class="pre">read_sector</span></code> 函数将磁盘中对应扇区的数据读到设备缓冲区中，或 <code class="docutils literal notranslate"><span class="pre">write_sector</span></code> 函数来缓冲区中的数据写入磁盘。注意，与控制台串口相同，磁盘操作中所有的地址操作都需要将物理地址转换成虚拟地址。此处设备基地址对应的 <code class="docutils literal notranslate"><span class="pre">kseg1</span></code> 的内核虚拟地址是 <code class="docutils literal notranslate"><span class="pre">0xB80001F0</span></code>。<br />
在磁盘读写的流程中，我们需要反复检查 IDE 设备是否已经就绪。这是由于 IDE 外设一般不能立即完成数据操作，需要 CPU 检查 IDE 状态并等待操作完成。为此我们构建了一个检查 IDE 状态的帮手函数 wait_ide，用于等待 IDE 上的操作就绪。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">u_int</span><span class="w"> </span><span class="nf">wait_ide</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>
<span class="w">	</span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="k">volatile</span><span class="w"> </span><span class="n">u_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_STATUS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">));</span>
<span class="w">		</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">flag</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">MALTA_IDE_BUSY</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">			</span><span class="k">break</span><span class="p">;</span>
<span class="w">		</span><span class="p">}</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">IDE</span></code> 设备就绪后，我们就可以对其进行读写操作了。<br />
首先，设置操作扇区的数目，这里我们只操作一个扇区，因此设置为 1。<br />
接下来，我们依次设置操作扇区号。本实验中使用的 IDE 设备无法一次性写入操作扇区号，因此需要单独设置扇区号的各位。特别地，在设置操作扇区号的[27:24]位时，还需要同时设置扇区寻址模式和磁盘编号，因此需要通过位运算将各值组合，并一齐写入对应地址。<br />
完成一系列设置后，再次等待 IDE 设备准备就绪，并在此之后，通过系统调用读取或写入扇区。由于本实验中使用的 IDE 设备每次仅能读取或写入 4 字节，因此需要通过一个循环完成整个扇区的读取或写入，即连续向相同的地址读取或写入 4 字节。<br />
最后，检查 IDE 设备状态，确认扇区读取和写入成功。<br />
具体地，对于读取扇区，我们可以实现 <code class="docutils literal notranslate"><span class="pre">read_sector</span></code> 函数，读取 <code class="docutils literal notranslate"><span class="pre">diskno</span></code> 号磁盘上的 <code class="docutils literal notranslate"><span class="pre">secno</span></code> 号扇区到 <code class="docutils literal notranslate"><span class="pre">dst</span></code> 指向的地址。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">read_sector</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">diskno</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">secno</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">wait_ide</span><span class="p">();</span>

<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_NSECT</span><span class="w"> </span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_LBAL</span><span class="w"> </span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">secno</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_LBAM</span><span class="w"> </span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">secno</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_LBAH</span><span class="w"> </span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">secno</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_DEVICE</span><span class="w"> </span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">	 </span><span class="p">((</span><span class="n">secno</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MALTA_IDE_LBA</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">diskno</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_STATUS</span><span class="w"> </span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MALTA_IDE_CMD_PIO_READ</span><span class="p">;</span>
<span class="w">	</span><span class="n">wait_ide</span><span class="p">();</span>
<span class="w">	</span><span class="k">for</span><span class="p">(</span><span class="n">inti</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="n">SECT_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_DATA</span><span class="o">+</span><span class="mh">0xA0000000</span><span class="p">),</span><span class="mi">4</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>类似的，我们也可以实现 <code class="docutils literal notranslate"><span class="pre">write_sector</span></code> 函数，将 <code class="docutils literal notranslate"><span class="pre">src</span></code> 指向的一个扇区的数据写入到 <code class="docutils literal notranslate"><span class="pre">diskno</span></code> 号磁盘的 <code class="docutils literal notranslate"><span class="pre">secno</span></code> 号扇区。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">write_sector</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">diskno</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">secno</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">wait_ide</span><span class="p">();</span>

<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_NSECT</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_LBAL</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">secno</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_LBAM</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">))</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">secno</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_LBAH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">))</span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">secno</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">;</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_DEVICE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="p">((</span><span class="n">secno</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0f</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">MALTA_IDE_LBA</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">diskno</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">	</span><span class="o">*</span><span class="p">((</span><span class="n">volatileu_char</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_STATUS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MALTA_IDE_CMD_PIO_WRITE</span><span class="p">;</span>
<span class="w">	</span><span class="n">wait_ide</span><span class="p">();</span>

<span class="w">	</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SECT_SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="n">MALTA_IDE_DATA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0xA0000000</span><span class="p">),</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>实现了磁盘驱动，我们可以尝试对磁盘进行读写测试。QEMU 允许通过启动参数来指定 IDE 磁盘镜像。编译生成的磁盘镜像文件位于 target/fs.img，我们可以在运行命令中加上 -driveid=ide0,file=target/fs.img,if=ide,format=raw 挂载该磁盘镜像。实验中我们挂载了两个磁盘镜像，其中一个是我们编译生成的磁盘镜像，另一个是空的磁盘镜像，完整命令如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">qemu</span><span class="o">-</span><span class="n">system</span><span class="o">-</span><span class="n">mipsel</span> 	\
	<span class="o">-</span><span class="n">cpu</span> <span class="mi">4</span><span class="n">Kc</span>		\
	<span class="o">-</span><span class="n">m</span> <span class="mi">64</span> <span class="o">-</span><span class="n">nographic</span>\
	<span class="o">-</span><span class="n">M</span> <span class="n">malta</span>		\
	<span class="o">-</span><span class="n">drive</span>	<span class="nb">id</span><span class="o">=</span><span class="n">ide0</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="n">target</span><span class="o">/</span><span class="n">fs</span><span class="o">.</span><span class="n">img</span><span class="p">,</span><span class="k">if</span><span class="o">=</span><span class="n">ide</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="n">raw</span>	\
	<span class="o">-</span><span class="n">drive</span> <span class="nb">id</span><span class="o">=</span><span class="n">ide1</span><span class="p">,</span><span class="n">file</span><span class="o">=</span><span class="n">target</span><span class="o">/</span><span class="n">empty</span><span class="o">.</span><span class="n">img</span><span class="p">,</span><span class="k">if</span><span class="o">=</span><span class="n">ide</span><span class="p">,</span><span class="nb">format</span><span class="o">=</span><span class="n">raw</span>  \
	<span class="o">-</span><span class="n">no</span><span class="o">-</span><span class="n">reboot</span>		\
	<span class="o">-</span><span class="n">kernel</span> <span class="n">target</span><span class="o">/</span><span class="n">mos</span>
</pre></div>
</div>
<p>我们通过 Makefile 简化了这个过程，可以直接运行make run来执行上述命令。</p>
</section>
</section>
<section id="id68">
<h2><span class="section-number">6.4. </span>文件系统结构<a class="headerlink" href="#id68" title="Link to this heading"></a></h2>
<p>实现了 IDE 磁盘的驱动，我们就有了在磁盘上实现文件系统的基础。接下来我们设计整个文件系统的结构，并在磁盘和操作系统中分别实现对应的结构。</p>
<section id="id69">
<h3><span class="section-number">6.4.1. </span>磁盘文件系统布局<a class="headerlink" href="#id69" title="Link to this heading"></a></h3>
<p>磁盘空间的基本布局如下图所示。</p>
<img alt="磁盘空间布局示意图" class="bg-primary align-center" src="_images/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E7%A4%BA%E6%84%8F%E5%9B%BE.png" />
<p>图中出现的 <code class="docutils literal notranslate"><span class="pre">Block</span></code> 是磁盘块。不同于扇区，磁盘块是一个虚拟概念，是操作系统与磁盘交互的最小单位；操作系统将相邻的扇区组合在一起，形成磁盘块进行整体操作，减小了因扇区过多带来的寻址困难；磁盘块的大小由操作系统决定，一般由2的幂次个扇区构成。而扇区是真实存在的，是磁盘读写的基本单位，与操作系统无关。<br />
从图中可以看到，la64 操作系统把磁盘最开始的一个磁盘块（4096字节）当作引导扇区和分区表使用。接下来的一个磁盘块作为超级块（SuperBlock），用来描述文件系统的基本信息，如Magic Number、磁盘大小以及根目录的位置。<br />
la64 操作系统中超级块的结构如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Super</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">s_magic</span><span class="p">;</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">s_nblocks</span><span class="p">;</span>
<span class="w">	</span><span class="c1">// Magic number: FS_MAGIC</span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">File</span><span class="w"> </span><span class="n">s_root</span><span class="p">;</span><span class="w"> </span><span class="c1">// Root directory node</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中每个域的意义如下：</p>
<ul class="simple">
<li><p>s_magic：魔数，为一个常量，用于标识该文件系统。</p></li>
<li><p>s_nblocks：记录本文件系统有多少个磁盘块，在本文件系统中为1024。</p></li>
<li><p>s_root：根目录，其 f_type 为 FTYPE_DIR，f_name 为“/”。</p></li>
</ul>
<p>通常采用两种数据结构来管理可用的资源：链表和位图。在 Lab2 “内存管理”和 Lab3 “进程与异常”实验中，我们使用了链表来管理空闲内存资源和进程控制块。在文件系统中，我们将使用位图(Bitmap) 法来管理空闲的磁盘资源，用一个二进制位 bit 标识磁盘中的一个磁盘块的使用情况（1表示空闲，0表示占用）。<br />
这里我们参考 <code class="docutils literal notranslate"><span class="pre">tools/fsformat.c</span></code> 来介绍文件系统标记空闲块的机制。<code class="docutils literal notranslate"><span class="pre">tools/fsformat.c</span></code> 是用于创建符合我们定义的文件系统镜像的工具，可以将多个文件按照内核所定义的文件系统写入到磁盘镜像中。通过观察头文件和 <code class="docutils literal notranslate"><span class="pre">tools/Makefile</span></code> ，我们可以看出，<code class="docutils literal notranslate"><span class="pre">tools/fsformat.c</span></code> 的编译过程与其他文件有所不同，其使用的是 Linux 下的 gcc 编译器，而非交叉编译器。编译生成的 fsformat 运行于 Linux 宿主机上，专门用于创建磁盘镜像文件。生成的镜像文件 fs.img 可以模拟与真实的磁盘文件设备的交互。<br />
在写入文件之前，<code class="docutils literal notranslate"><span class="pre">tools/fsformat.c</span></code> 的 <code class="docutils literal notranslate"><span class="pre">init_disk</span></code> 函数，将所有的块都标为空闲块：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">nbitblock</span> <span class="o">=</span> <span class="p">(</span><span class="n">NBLOCK</span> <span class="o">+</span> <span class="n">BLOCK_SIZE_BIT</span><span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BLOCK_SIZE_BIT</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbitblock</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">disk</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BLOCK_BMAP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbitblock</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">disk</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">BLOCK_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NBLOCK</span> <span class="o">!=</span> <span class="n">nbitblock</span> <span class="o">*</span> <span class="n">BLOCK_SIZE_BIT</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">NBLOCK</span> <span class="o">%</span> <span class="n">BLOCK_SIZE_BIT</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">disk</span><span class="p">[</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">nbitblock</span><span class="o">-</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">diff</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">BLOCK_SIZE</span><span class="o">-</span> <span class="n">diff</span><span class="p">);</span>
	<span class="p">}</span>
</pre></div>
</div>
<p>nbitblock 表示为了用位图标识整个磁盘上所有块的使用情况所需要的磁盘块（bitblock，位图块）的数量。紧接着，我们使用 memset 将位图中的每一个字节（Byte）都设成 0xff，即将所有位图块的每一位都设为 1，表示磁盘块处于空闲状态。如果位图还有剩余，不能将最后一块位图块中靠后的一部分内容标记为空闲，因为这些位所对应的磁盘块并不存在，是不可使用的。因此，将所有的位图块的每一位都置为 1 之后，还需要根据实际情况，将位图不存在的部分设为 0。<br />
相应地，在 la64 操作系统中，文件系统也需要根据位图来判断和标记磁盘的使用情况。<code class="docutils literal notranslate"><span class="pre">fs/fs.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">block_is_free</span></code> 函数就用来通过位图中的特定位来判断指定的磁盘块是否被占用。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">block_is_free</span><span class="p">(</span><span class="n">u_int</span><span class="w"> </span><span class="n">blockno</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">super</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">blockno</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">super</span><span class="o">-&gt;</span><span class="n">s_nblocks</span><span class="p">)</span>
<span class="w">	</span><span class="p">{</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">blockno</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">blockno</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">32</span><span class="p">)))</span>
<span class="w">	</span><span class="p">{</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id70">
<h3><span class="section-number">6.4.2. </span>文件系统详细结构<a class="headerlink" href="#id70" title="Link to this heading"></a></h3>
<p>操作系统要想管理一类资源，就得有相应的数据结构。对于描述和管理文件来说，一般使用文件控制块（File结构体）。其定义如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">File</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kt">char</span><span class="w"> </span><span class="n">f_name</span><span class="p">[</span><span class="n">MAXNAMELEN</span><span class="p">];</span><span class="c1">//filename</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">f_size</span><span class="p">;</span><span class="w"> </span><span class="c1">//filesizeinbytes</span>
<span class="w">	</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">f_type</span><span class="p">;</span><span class="w"> </span><span class="c1">//filetype</span>
<span class="w">	</span><span class="n">uint32_tf_direct</span><span class="p">[</span><span class="n">NDIRECT</span><span class="p">];</span>
<span class="w">	</span><span class="n">uint32_tf_indirect</span><span class="p">;</span>

<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">File</span><span class="w"> </span><span class="o">*</span><span class="n">f_dir</span><span class="p">;</span><span class="c1">//thepointertothedirwherethisfileisin,validonlyinmemory.</span>
<span class="w">	</span><span class="kt">char</span><span class="w"> </span><span class="n">f_pad</span><span class="p">[</span><span class="n">FILE_STRUCT_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">MAXNAMELEN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NDIRECT</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)];</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">packed</span><span class="p">));</span>
</pre></div>
</div>
<p>结合文件控制块的示意图，我们对各个域进行解读：f_name 为文件名称，文件名的最大长度 MAXNAMELEN 值为 128。f_size 为文件的大小，单位为字节。f_type 为文件类型，有普通文件(FTYPE_REG)和目录(FTYPE_DIR)两种。f_direct[NDIRECT] 为文件的直接指针，每个文件控制块设有 10 个直接指针，用来记录文件的数据块在磁盘上的位置。每个磁盘块的大小为 4 KB，也就是说，这十个直接指针能够表示最大 40 KB的文件，而当文件的大小大于 40 KB时，就需要用到间接指针。f_indirect 指向一个间接磁盘块，用来存储指向文件内容的磁盘块的指针。为了简化计算，我们不使用间接磁盘块的前十个指针。f_dir 指向文件所属的文件目录。f_pad 则是为了让整数个文件结构体占用一个磁盘块，填充结构体中剩下的字节。</p>
<img alt="文件控制块示意图" class="bg-primary align-center" src="_images/%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97.png" />
<p>对于普通的文件，其指向的磁盘块存储着文件内容，而对于目录文件来说，其指向的磁盘块存储着该目录下各个文件对应的文件控制块。当我们要查找某个文件时，首先从超级块中读取根目录的文件控制块，然后沿着目标路径，挨个查看当前目录所包含的文件是否与下一级目标文件同名，如此便能查找到最终的目标文件。<br />
请阅读 <code class="docutils literal notranslate"><span class="pre">tools/fsformat.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fs/Makefile</span></code>，掌握如何将文件和目录按照文件系统的格式写入磁盘，了解文件系统结构的具体细节，学会添加自定义文件进入磁盘镜像。（fsformat.c 中的主函数十分灵活，可以通过修改命令行参数来生成不同的镜像文件）</p>
</section>
<section id="id71">
<h3><span class="section-number">6.4.3. </span>块缓存<a class="headerlink" href="#id71" title="Link to this heading"></a></h3>
<p>块缓存指的是借助虚拟内存来实现磁盘块缓存的设计。由于对于硬盘 I/O 操作一次只能读取少量数据，同时频繁读写磁盘会拖慢系统，故常用块缓存将数据暂存于内存，减少磁盘访问次数，从而加快数据读取。la64 操作系统中，文件系统服务是一个用户进程（将在下文介绍），一个进程可以拥有 4 GB的虚拟内存空间，将 <code class="docutils literal notranslate"><span class="pre">DISKMAP</span></code> 到 <code class="docutils literal notranslate"><span class="pre">DISKMAP</span> <span class="pre">+</span> <span class="pre">DISKMAX</span></code> 这一段虚存地址空间 (0x10000000-0x4FFFFFFF) 作为缓冲区，当磁盘读入内存时，用来映射相关的页。<code class="docutils literal notranslate"><span class="pre">DISKMAP</span></code> 和 <code class="docutils literal notranslate"><span class="pre">DISKMAX</span></code> 的值定义在 fs/serv.h 中：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define DISKMAP 0x10000000</span>
<span class="cp">#define DISKMAX 0x40000000</span>
</pre></div>
</div>
<p>为了建立起磁盘地址空间和进程虚存地址空间之间的缓存映射，我们采用的设计如下图所示。</p>
<img alt="块缓存示意图" class="bg-primary align-center" src="_images/%E5%9D%97%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" />
<p>当把一个磁盘块中的内容载入到内存中时，需要为之分配对应的物理内存；当结束使用这一磁盘块时，需要释放对应的物理内存以回收操作系统资源。fs/fs.c 中的 map_block 函数和 unmap_block 函数实现了这一功能。<br />
<code class="docutils literal notranslate"><span class="pre">read_block</span></code> 函数和 <code class="docutils literal notranslate"><span class="pre">write_block</span></code> 函数用于读写磁盘块。<code class="docutils literal notranslate"><span class="pre">read_block</span></code> 函数将指定编号的磁盘块读入到内存中，首先检查这块磁盘块是否已经在内存中，如果不在，先分配一页物理内存，然后调用 <code class="docutils literal notranslate"><span class="pre">ide_read</span></code> 函数来读取磁盘上的数据到对应的虚存地址处。<br />
<code class="docutils literal notranslate"><span class="pre">file_get_block</span></code> 函数用于将某个指定的文件指向的磁盘块读入内存。其主要分为 2 个步骤：首先为即将读入内存的磁盘块分配物理内存，然后使用 <code class="docutils literal notranslate"><span class="pre">read_block</span></code> 函数将磁盘内容以块为单位读入内存中的相应位置。这两个步骤对应的函数都借助了系统调用来完成。<br />
在完成块缓存部分之后我们就可以实现文件系统中的一些文件操作了。<br />
这里我们给出了文件系统结构中部分函数可能的调用参考，如下图所示，希望同学们认真理解每个文件、函数的作用和之间的关系。</p>
<img alt="fs下部分函数调用关系参考" class="bg-primary align-center" src="_images/fs%E4%B8%8B%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%8F%82%E8%80%83.png" />
</section>
</section>
<section id="id72">
<h2><span class="section-number">6.5. </span>文件系统的用户接口<a class="headerlink" href="#id72" title="Link to this heading"></a></h2>
<p>在文件系统建立之后，还需要向用户提供相关的使用接口。la64 操作系统内核符合一个典型的微内核的设计，文件系统属于用户态进程，以服务的形式供其他进程调用。这个过程中，不涉及了不同进程之间通信的问题，也涉及了文件系统如何隔离底层的文件系统实现，抽象地表示一个文件的问题。首先，我们引入文件描述符（filedescriptor）作为用户程序管理、操作文件的基础。</p>
<section id="id73">
<h3><span class="section-number">6.5.1. </span>文件描述符<a class="headerlink" href="#id73" title="Link to this heading"></a></h3>
<p>当用户进程试图打开一个文件时，文件系统服务进程需要一个文件描述符来存储文件的基本信息和用户进程中关于文件的状态；同时，文件描述符也起到描述用户对于文件操作的作用。当用户进程向文件系统发送打开文件的请求时，文件系统进程会将这些基本信息记录在内存中，然后由操作系统将用户进程请求的地址映射到同一个存储了文件描述符的物理页上（此部分代码位于 serv.c 的 serve_open 函数内），因此一个文件描述符至少需要独占一页的空间。当用户进程获取了文件大小等基本信息后，再次向文件系统发送请求将文件内容映射到指定内存空间中。<br />
阅读 <code class="docutils literal notranslate"><span class="pre">user/lib/file.c</span></code> 时，我们会发现很多函数中都会将一个 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Fd</span> <span class="pre">*</span></code> 型的指针转换为 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Filefd*</span></code> 型的指针，这是基于 C 语言中关于指针的强制类型转换来实现的。该类型转换并不改变指针的值，仅改变程序对地址处数据的解释方式两个结构体的定义如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Fd</span><span class="p">{</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">fd_dev_id</span><span class="p">;</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">fd_offset</span><span class="p">;</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">fd_omode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Filefd</span><span class="p">{</span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">Fd</span><span class="w"> </span><span class="n">f_fd</span><span class="p">;</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">f_fileid</span><span class="p">;</span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">File</span><span class="w"> </span><span class="n">f_file</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>对于类型为 Fd 的一段内存，该段内存开头被解释为三个 u_int 类型的数据。将其强制转换为 Filefd 类型之后，由于 Filefd 第一个成员是 Fd 类型，对这段内存开始部分的解释依旧可以是三个 u_int 类型的数据（通过f_fd成员即可访问到）。同时第二个成员开始的内存将会按照 FileFd 的定义进行解释。若将 Filefd 类型强制转换为 Fd 将会遮盖掉不同细分类别的文件描述符的不同，有利于统一操作。<br />
当要读取一个大文件中间的一小部分内容时，一个简单的做法是从头开始查找，但这样的开销很大；此外，在多次读写同一文件描述符期间，我们也希望能够从文件中前一次读写完毕的位置开始，继续读写数据。因此，文件描述符中需要维护一个指针，以帮助我们在文件中定位；在实现 read、write 和 seek 等操作时，也需要更新该指针的值。</p>
</section>
<section id="id74">
<h3><span class="section-number">6.5.2. </span>文件系统服务<a class="headerlink" href="#id74" title="Link to this heading"></a></h3>
<p>la64 操作系统中的文件系统服务通过 IPC 的形式供其他进程调用，进行文件读写操作。具体来说，在内核开始运行时，就启动了文件系统服务进程 <code class="docutils literal notranslate"><span class="pre">ENV_CREATE(fs_serv)</span></code>，用户进程需要进行文件操作时，使用 <code class="docutils literal notranslate"><span class="pre">ipc_send</span></code>、<code class="docutils literal notranslate"><span class="pre">ipc_recv</span></code> 与 <code class="docutils literal notranslate"><span class="pre">fs_serv</span></code> 进行交互，完成操作。<code class="docutils literal notranslate"><span class="pre">fs/serv.c</span></code> 中服务进程的主函数首先调用了 <code class="docutils literal notranslate"><span class="pre">serve_init</span></code> 函数准备好全局的文件打开记录表 <code class="docutils literal notranslate"><span class="pre">opentab</span></code>，然后调用 <code class="docutils literal notranslate"><span class="pre">fs_init</span></code> 函数来初始化文件系统。<code class="docutils literal notranslate"><span class="pre">fs_init</span></code> 函数首先通过读取超级块的内容获知磁盘的基本信息，然后检查磁盘是否能够正常读写，最后调用 <code class="docutils literal notranslate"><span class="pre">read_bitmap</span></code> 函数检查磁盘块上的位图是否正确。执行完文件系统的初始化后，调用 <code class="docutils literal notranslate"><span class="pre">serve</span></code> 函数，文件系统服务开始运行，等待其他程序的请求。<br />
下图以 UML 时序图的形式在宏观层面上展示了一个用户进程请求文件系统服务的过程（以 open 为例）。其中 <code class="docutils literal notranslate"><span class="pre">user_env</span></code> 所加载的程序不仅可以是实验源码已给出的 <code class="docutils literal notranslate"><span class="pre">fstest.c</span></code>, 也可以是其他以 main 为入口函数的用户程序，你可以通过这种方式对文件系统服务进行测试。其中 <code class="docutils literal notranslate"><span class="pre">IPC</span></code> 系统调用的细节请参考 <code class="docutils literal notranslate"><span class="pre">Lab4</span></code> 的相关内容。（三种颜色不仅区分三个不同的程序，也表示进程执行的代码在我们的操作系统被载入内存前所处的文件位置）</p>
<img alt="文件系统服务时序图" class="bg-primary align-center" src="_images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%97%B6%E5%BA%8F%E5%9B%BE.png" />
<p>文件系统支持的请求类型定义在 <code class="docutils literal notranslate"><span class="pre">user/include/fsreq.h</span></code> 中，包含以下几种：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">FSREQ_OPEN</span><span class="p">,</span>
<span class="w">	</span><span class="n">FSREQ_MAP</span><span class="p">,</span>
<span class="w">	</span><span class="n">FSREQ_SET_SIZE</span><span class="p">,</span>
<span class="w">	</span><span class="n">FSREQ_CLOSE</span><span class="p">,</span>
<span class="w">	</span><span class="n">FSREQ_DIRTY</span><span class="p">,</span>
<span class="w">	</span><span class="n">FSREQ_REMOVE</span><span class="p">,</span>
<span class="w">	</span><span class="n">FSREQ_SYNC</span><span class="p">,</span>
<span class="w">	</span><span class="n">MAX_FSREQNO</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>用户程序在发出文件系统操作请求时，将请求的内容放在对应的结构体中进行消息的传递，fs_serv 进程收到其他进行的 IPC 请求后，IPC 传递的消息包含了请求的类型和其他必要的参数，根据请求的类型执行相应的文件操作（文件的增、删、改、查等），将结果重新通过 IPC 反馈给用户程序。<br />
文件 <code class="docutils literal notranslate"><span class="pre">user/lib/fsipc.c</span></code> 中定义了请求文件系统时用到的 <code class="docutils literal notranslate"><span class="pre">IPC</span></code> 操作，<code class="docutils literal notranslate"><span class="pre">user/lib/file.c</span></code> 文件中定义了用户程序读写、创建、删除和修改文件的接口。完成以下练习，实现删除指定路径的文件的功能。<br />
这里我们给出了文件系统的用户接口中部分函数可能的调用参考图，希望同学们体会函数之间的调用关系、理解文件系统中用户接口的实现过程。</p>
<img alt="lib下部分函数调用关系参考" class="bg-primary align-center" src="_images/lib%E4%B8%8B%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%8F%82%E8%80%83.png" />
</section>
</section>
<section id="id75">
<h2><span class="section-number">6.6. </span>实验结果展示<a class="headerlink" href="#id75" title="Link to this heading"></a></h2>
<p>本实验有三个阶段性测试可以检验你实现的文件系统的正确性。</p>
<section id="id76">
<h3><span class="section-number">6.6.1. </span>IDE 磁盘交互<a class="headerlink" href="#id76" title="Link to this heading"></a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">init/init.c</span></code> 中仅启动 devtst 进程，使用 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">&amp;&amp;</span> <span class="pre">make</span> <span class="pre">run</span></code> 编译运行内核，将对 Console 和 IDE 磁盘交互进行测试</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">ENV_CREATE</span><span class="p">(</span><span class="n">user_devtst</span><span class="p">);</span>
</pre></div>
</div>
<p>也可以使用 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span> <span class="pre">lab=5_1</span></code>直接构建。<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">run</span></code> 后，输入一个字符串 <code class="docutils literal notranslate"><span class="pre">01234567890123</span></code> 并按下回车，正确结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">devtst</span> <span class="n">begin</span>
<span class="mi">01234567890123</span>
<span class="n">syscall_read_dev</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">end</span> <span class="n">of</span> <span class="n">devtst</span>
<span class="n">dev</span> <span class="n">address</span> <span class="ow">is</span> <span class="n">ok</span>
</pre></div>
</div>
</section>
<section id="id77">
<h3><span class="section-number">6.6.2. </span>文件系统测试<a class="headerlink" href="#id77" title="Link to this heading"></a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">init/init.c</span></code> 中仅启动文件系统服务进程，该进程在正式开始服务前，会执行 <code class="docutils literal notranslate"><span class="pre">fs/check.c</span></code> 中的单元测试。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">ENV_CREATE</span><span class="p">(</span><span class="n">fs_serv</span><span class="p">);</span>
</pre></div>
</div>
<p>正确结果如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FS</span> <span class="ow">is</span> <span class="n">running</span>
<span class="n">superblock</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">read_bitmap</span> <span class="ow">is</span> <span class="n">good</span>
</pre></div>
</div>
</section>
<section id="id78">
<h3><span class="section-number">6.6.3. </span>文件系统服务测试<a class="headerlink" href="#id78" title="Link to this heading"></a></h3>
<p>完成全部学习后，启动一个 <code class="docutils literal notranslate"><span class="pre">fstest</span></code> 进程和文件系统服务进程：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">ENV_CREATE</span><span class="p">(</span><span class="n">user_fstest</span><span class="p">);</span>
	<span class="n">ENV_CREATE</span><span class="p">(</span><span class="n">fs_serv</span><span class="p">);</span>
</pre></div>
</div>
<p>就能开始对文件系统的检测，运行文件系统服务，等待应用程序的请求。注意：我们此时必须将文件系统进程作为第二个进程启动，其原因是我们在 <code class="docutils literal notranslate"><span class="pre">user/lib/fsipc.c</span></code> 中定义的文件系统 <code class="docutils literal notranslate"><span class="pre">IPC</span></code> 请求的目标指定为第二个创建的进程。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FS</span> <span class="ow">is</span> <span class="n">running</span>
<span class="n">superblock</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">read_bitmap</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">serve_open</span> <span class="mi">00000800</span> <span class="n">ffff000</span> <span class="mh">0x2</span>
<span class="nb">open</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">read</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">serve_open</span> <span class="mi">00000800</span> <span class="n">ffff000</span> <span class="mh">0x0</span>
<span class="nb">open</span> <span class="n">again</span><span class="p">:</span> <span class="n">OK</span>
<span class="n">read</span> <span class="n">again</span><span class="p">:</span> <span class="n">OK</span>
<span class="n">file</span> <span class="n">rewrite</span> <span class="ow">is</span> <span class="n">good</span>
<span class="n">serve_open</span> <span class="mi">00000800</span> <span class="n">ffff000</span> <span class="mh">0x0</span>
<span class="n">file</span> <span class="n">remove</span><span class="p">:</span> <span class="n">OK</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="shell">
<h1><span class="section-number">7. </span>实验六：管道与 SHELL<a class="headerlink" href="#shell" title="Link to this heading"></a></h1>
<section id="id79">
<h2><span class="section-number">7.1. </span>实验目的<a class="headerlink" href="#id79" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>掌握管道的原理与底层细节</p></li>
<li><p>实现管道的读写</p></li>
<li><p>复述管道竞争情景</p></li>
<li><p>实现基本 shell</p></li>
<li><p>实现 shell 中涉及管道的部分</p></li>
</ol>
</section>
<section id="id80">
<h2><span class="section-number">7.2. </span>管道<a class="headerlink" href="#id80" title="Link to this heading"></a></h2>
<p>在 Lab4 中，我们已经学习过一种进程间通信(IPC,Inter-ProcessCommunication)的方式—共享内存。而今天我们要学的管道，其实也是进程间通信的一种方式。</p>
<section id="id81">
<h3><span class="section-number">7.2.1. </span>初窥管道<a class="headerlink" href="#id81" title="Link to this heading"></a></h3>
<p>管道是一种典型的进程间单向通信的方式。管道分有名管道和匿名管道两种，匿名管道只能在具有公共祖先的进程之间使用，且通常使用在父子进程之间。在 la64 中，我们要实现匿名管道。本章后续所称的管道，没有特别说明，均指匿名管道。<br />
在 Unix 中，管道由 int pipe(intfd[2]) 函数创建，成功创建管道返回 0，参数中的 fd 用来保存读写端的文件描述符，fd[0] 对应读端，fd[1] 对应写端。<br />
为了更好地理解管道实现的原理，我们先来做一个小实验体会一下。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">fildes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">	</span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipe</span><span class="p">(</span><span class="n">fildes</span><span class="p">);</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">	</span><span class="p">{</span>
<span class="w">		</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>

<span class="w">	</span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">fork</span><span class="p">())</span>
<span class="w">	</span><span class="p">{</span>
<span class="w">		</span><span class="k">case</span><span class="w"> </span><span class="mi">-1</span><span class="p">:</span>
<span class="w">			</span><span class="k">break</span><span class="p">;</span>
<span class="w">		</span>
<span class="w">		</span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w">	 </span><span class="cm">/*子进程-作为管道的读者*/</span>
<span class="w">			</span><span class="n">close</span><span class="p">(</span><span class="n">fildes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="cm">/*关闭不用的写端*/</span>
<span class="w">			</span><span class="n">read</span><span class="p">(</span><span class="n">fildes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w"> </span><span class="cm">/*从管道中读数据*/</span>
<span class="w">			</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;child-processread:%s&quot;</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/*打印读到的数据*/</span>
<span class="w">			</span><span class="n">close</span><span class="p">(</span><span class="n">fildes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="cm">/*读取结束，关闭读端*/</span>
<span class="w">			</span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>

<span class="w">		</span><span class="k">default</span><span class="o">:</span>
<span class="w">			</span><span class="n">close</span><span class="p">(</span><span class="n">fildes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="w"> </span><span class="cm">/*关闭不用的读端*/</span>
<span class="w">			</span><span class="n">write</span><span class="p">(</span><span class="n">fildes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&quot;Helloworld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">12</span><span class="p">);</span><span class="w"> </span><span class="cm">/*向管道中写数据*/</span>
<span class="w">			</span><span class="n">close</span><span class="p">(</span><span class="n">fildes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w"> </span><span class="cm">/*写入结束，关闭写端*/</span>
<span class="w">			</span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>你可以将示例代码复制到 Linux 环境，使用命令 <code class="docutils literal notranslate"><span class="pre">gcctest_pipe.c</span> <span class="pre">&amp;&amp;</span> <span class="pre">./a.out</span></code> 来执行。<br />
示例代码实现了从父进程向管道中写入消息 <code class="docutils literal notranslate"><span class="pre">Hello,world</span></code>，子进程从管道中读出数据并打印到屏幕上。它演示了管道在父子进程之间通信的基本用法：父进程在 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 函数之后，调用 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 来产生一个子进程，之后在父子进程中各自执行不同的操作：关掉自己不会用到的管道端，然后进行相应的读写操作。在示例代码中，父进程操作写端，而子进程操作读端。<br />
从本质上说，管道是一种只存在于内存中的文件。在 <code class="docutils literal notranslate"><span class="pre">UNIX</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">la64</span></code>中，父进程调用 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 函数时，会打开两个新的文件描述符：一个表示只读端，另一个表示只写端，两个描述符都映射到了同一片内存区域。在 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 的配合下，子进程复制父进程的两个文件描述符，从而在父子进程间形成了四个（父子各拥有一读一写）指向同一片内存区域的文件描述符，父子进程可根据需要关掉自己不用的一个，从而实现父子进程间的单向通信管道，这也是匿名管道只能用在具有亲缘关系的进程间通信的原因。</p>
</section>
<section id="la64-pipe">
<h3><span class="section-number">7.2.2. </span>la64 中 pipe 的使用与实现<a class="headerlink" href="#la64-pipe" title="Link to this heading"></a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">la64</span></code> 中，管道的使用和 <code class="docutils literal notranslate"><span class="pre">UNIX</span></code> 系统的示例代码逻辑相同。<code class="docutils literal notranslate"><span class="pre">la64</span></code> 中使用管道的示例代码为 <code class="docutils literal notranslate"><span class="pre">user/testpipe.c</span></code>。<br />
示例代码中先使用函数 <code class="docutils literal notranslate"><span class="pre">pipe(int</span> <span class="pre">p[2])</span></code> 创建了管道，读端的文件描述符（fd）编号为 p[0]，写端的文件描述符编号为 p[1]。之后使用 <code class="docutils literal notranslate"><span class="pre">fork()</span></code> 创建子进程，注意这时父子进程使用自己的 p[0] 和 p[1] 访问到的内存区域是一致的。之后子进程关闭了自己的 p[1]，从 p[0] 读；父进程关闭了自己的 p[0],从 p[1] 写入管道。<br />
在管道读写的过程中，我们需要保证写端对管道的写入对读端可见，也就是保证父子进程通过管道访问的内存相同。下面我们通过对 <code class="docutils literal notranslate"><span class="pre">user/lib/pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 函数的具体实现来介绍如何实现这一需求。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">pfd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">	</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">va</span><span class="p">;</span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">Fd</span><span class="w"> </span><span class="o">*</span><span class="n">fd0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">fd1</span><span class="p">;</span>

<span class="w">	</span><span class="cm">/* Step 1: Allocate the file descriptors. */</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd0</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscall_mem_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fd0</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_D</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_LIBRARY</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>

<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd1</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscall_mem_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fd1</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_D</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_LIBRARY</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">err1</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>

<span class="w">	</span><span class="cm">/* Step 2: Allocate and map the page for the &#39;Pipe&#39; structure. */</span>
<span class="w">	</span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fd2data</span><span class="p">(</span><span class="n">fd0</span><span class="p">);</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscall_mem_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_D</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_LIBRARY</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">err2</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscall_mem_map</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">fd2data</span><span class="p">(</span><span class="n">fd1</span><span class="p">),</span><span class="w"> </span><span class="n">PTE_D</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_LIBRARY</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span>
<span class="w">	    </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">		</span><span class="k">goto</span><span class="w"> </span><span class="n">err3</span><span class="p">;</span>
<span class="w">	</span><span class="p">}</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 中，首先分配两个文件描述符 <code class="docutils literal notranslate"><span class="pre">fd0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fd1</span></code> 并为其分配空间，然后给 <code class="docutils literal notranslate"><span class="pre">fd0</span></code> 对应的虚拟地址分配一页物理内存，再将 <code class="docutils literal notranslate"><span class="pre">fd1</span></code> 对应的虚拟地址映射到这一页物理内存。<br />
我们曾在 <code class="docutils literal notranslate"><span class="pre">Lab4</span></code> 填写 <code class="docutils literal notranslate"><span class="pre">duppage</span></code> 函数时介绍过这类页面，即“共享页面”。共享页面是具有权限位 <code class="docutils literal notranslate"><span class="pre">PTE_LIBRARY</span></code> 的页面，需要保持共享可写的状态，使得父子进程对其进行修改的结果相互可见。当父子进程试图写共享页面时，直接在该页面上进行写操作即可。<br />
仔细观察 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 中出现的权限位 <code class="docutils literal notranslate"><span class="pre">PTE_LIBRARY</span></code>，根据上述提示检查你在 <code class="docutils literal notranslate"><span class="pre">Lab4</span></code> 实现的 <code class="docutils literal notranslate"><span class="pre">user/lib/fork.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">duppage</span></code> 函数，保证它能根据父页面的不同权限位，为子页面设置对应的权限位，以此区分实现 <code class="docutils literal notranslate"><span class="pre">Lab4</span></code> 所需的写时复制机制或者 <code class="docutils literal notranslate"><span class="pre">Lab6</span></code> 中管道所需的共享页面机制。<br />
下面我们使用下图来表示父子进程与管道的数据缓冲区的关系：</p>
<img alt="父子进程与管道缓冲区" class="bg-primary align-center" src="_images/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%AE%A1%E9%81%93%E7%BC%93%E5%86%B2%E5%8C%BA.png" />
<p>实际上，在父子进程中各自 <code class="docutils literal notranslate"><span class="pre">close</span></code> 掉不再使用的端口后，父子进程与管道缓冲区的关系如图所示。</p>
<img alt="关闭不使用的端口后" class="bg-primary align-center" src="_images/%E5%85%B3%E9%97%AD%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%8E.png" />
<p>下面我们来讲一下 <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">Pipe</span></code>，并开始着手填写操作管道端的函数。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Pipe</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">p_rpos</span><span class="p">;</span><span class="w">			</span><span class="c1">// read position</span>
<span class="w">	</span><span class="n">u_int</span><span class="w"> </span><span class="n">p_wpos</span><span class="p">;</span><span class="w">			</span><span class="c1">// write position</span>
<span class="w">	</span><span class="n">u_char</span><span class="w"> </span><span class="n">p_buf</span><span class="p">[</span><span class="n">PIPE_SIZE</span><span class="p">];</span><span class="w"> </span><span class="c1">// data buffer</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">Pipe</span></code> 结构体中,<code class="docutils literal notranslate"><span class="pre">p_rpos</span></code> 给出了下一个将要从管道读的数据的位置，而 <code class="docutils literal notranslate"><span class="pre">p_wpos</span></code> 给出了下一个将要向管道写的数据的位置。只有读者可以更新 <code class="docutils literal notranslate"><span class="pre">p_rpos</span></code>，同样，只有写者可以更新 <code class="docutils literal notranslate"><span class="pre">p_wpos</span></code>，读者和写者通过这两个变量的值进行读写的协调。<br />
一个管道有 <code class="docutils literal notranslate"><span class="pre">PIPE_SIZE(32</span> <span class="pre">Byte)</span></code> 大小的缓冲区。这个 <code class="docutils literal notranslate"><span class="pre">PIPE_SIZE</span></code> 大小的缓冲区发挥的作用类似于环形缓冲区，所以下一个要读或写的位置 i 实际上是 <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">%</span> <span class="pre">PIPE_SIZE</span></code>。<br />
读者在从管道读取数据时，要将 <code class="docutils literal notranslate"><span class="pre">p_buf[p_rpos%PIPE_SIZE]</span></code> 中的数据拷贝走，然后读指针自增 1。但是需要注意的是，管道的缓冲区此时可能还没有被写入数据。所以如果管道数据为空，即当 <code class="docutils literal notranslate"><span class="pre">p_rpos</span> <span class="pre">&gt;=</span> <span class="pre">p_wpos</span></code> 时，应该进程切换到写者运行。<br />
类似于读者，写者在向管道写入数据时，也是将数据存入 <code class="docutils literal notranslate"><span class="pre">p_buf[p_wpos%PIPE_SIZE]</span></code>，然后写指针自增 1。需要注意管道的缓冲区可能出现满溢的情况，所以写者必须得在 <code class="docutils literal notranslate"><span class="pre">p_wposp_rpos</span> <span class="pre">&lt;</span> <span class="pre">PIPE_SIZE</span></code> 时方可运行，否则要一直挂起。<br />
上面这些还不能保证读者写者一定能顺利完成管道操作。假设这样的情景：管道写端已经全部关闭，读者读到缓冲区有效数据的末尾，此时有 <code class="docutils literal notranslate"><span class="pre">p_rpos</span> <span class="pre">=</span> <span class="pre">p_wpos</span></code>。按照上面的做法，我们这里应当切换到写者运行。但写者进程已经结束，进程切换就造成了死循环，这时候读者进程如何知道应当退出了呢？<br />
为了解决上面提出的问题，我们必须知道管道的另一端是否已经关闭。不论是读者还是写者进程，我们都需要对管道另一端的状态进行判断：当出现缓冲区空或满的情况时，要根据另一端是否关闭来判断是否要返回。如果另一端已经关闭，进程返回0即可；如果没有关闭，则切换进程运行。<br />
管道的关闭涉及到以下几个函数：<code class="docutils literal notranslate"><span class="pre">fd.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">close</span></code>，<code class="docutils literal notranslate"><span class="pre">fd_close</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">pipe_close</span></code>，请自行阅读并结合分析。<br />
在 <code class="docutils literal notranslate"><span class="pre">la64</span></code> 中，我们使用 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">_pipe_is_closed(struct</span> <span class="pre">Fd</span> <span class="pre">*fd,</span> <span class="pre">struct</span> <span class="pre">Pipe</span> <span class="pre">*p)</span></code> 函数来判断管道的另一端是否已经关闭。这个函数的核心，就是下面要讲的恒成立等式。<br />
在之前的图中我们没有明确画出文件描述符所占的页，但实际上，对于每一个匿名管道而言，我们分配了三页空间：一页是读数据的文件描述符 <code class="docutils literal notranslate"><span class="pre">rfd</span></code>，一页是写数据的文件描述符 <code class="docutils literal notranslate"><span class="pre">wfd</span></code>，剩下一页是被两个文件描述符共享的管道数据缓冲区 <code class="docutils literal notranslate"><span class="pre">pipe</span></code>。既然管道数据缓冲区是被两个文件描述符所共享的，我们很直观地就能得到一个结论：如果有 1 个读者，1 个写者，那么管道将被引用 2 次（正如之前所给图所示）。<code class="docutils literal notranslate"><span class="pre">pageref</span></code> 函数能得到页的引用次数，所以有下面这个等式成立：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pageref</span><span class="p">(</span><span class="n">rfd</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pageref</span><span class="p">(</span><span class="n">wfd</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pageref</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span>
</pre></div>
</div>
<p>我们将借助这个恒等式判断管道另一端是否已经关闭。假设现在读者进程正在运行，而管道写者进程已经结束了，那么此时就应该有：<code class="docutils literal notranslate"><span class="pre">pageref(wfd)</span> <span class="pre">=</span> <span class="pre">0。所以就有</span> <span class="pre">pageref(rfd)</span> <span class="pre">=</span> <span class="pre">pageref(pipe)</span></code>。因此，只要判断这个等式是否成立就可以得知写端是否关闭。对写者来说同理。</p>
</section>
<section id="id82">
<h3><span class="section-number">7.2.3. </span>管道关闭的正确判断<a class="headerlink" href="#id82" title="Link to this heading"></a></h3>
<p>la64 操作系统采用的是时间片轮转调度的进程调度算法，有关这点，你应在 <code class="docutils literal notranslate"><span class="pre">Lab3</span></code> 中就深有体会了。这种抢占式的进程管理意味着，用户进程随时可能会被打断。<br />
当然，如果进程间是孤立的，随时打断也没有关系。但当多个进程共享同一个变量时，不同的进程执行顺序有可能产生完全不同的结果，造成运行结果的不确定性。而进程通信需要共享同一块内存（不论是管道还是共享内存），所以我们要对进程中共享变量的读写操作有足够高的警惕。<br />
因此，因为管道本身的共享性质，在当前这种不加锁控制的情况下，无法保证 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 用于管道另一端关闭的判断一定返回正确的结果。<br />
进程通过 <code class="docutils literal notranslate"><span class="pre">pipe_close</span></code> 函数来关闭管道的端口，该函数的实质是通过两次系统调用 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 解除文件描述符 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 和数据缓存区 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的映射。但是由于进程切换的存在，并不能保证两次系统调用可以在同一进程时间片内被执行，两次系统调用之间可能因为进程切换而被打断。所以，<code class="docutils literal notranslate"><span class="pre">fd</span></code> 和对 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pp_ref</span></code> 也不能保证同步被写入，这将影响我们判断管道是否关闭的正确性。<br />
结合下文的代码，考虑以下场景：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">	</span><span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">	</span><span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="w">	</span><span class="p">{</span>
<span class="w">		</span><span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">		</span><span class="n">read</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
<span class="w">	</span><span class="k">else</span>
<span class="w">	</span><span class="p">{</span>
<span class="w">		</span><span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">		</span><span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">	</span><span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>假设 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 结束后，子进程先执行。时钟中断产生在 <code class="docutils literal notranslate"><span class="pre">close(p[1])</span></code> 与 <code class="docutils literal notranslate"><span class="pre">read</span></code> 之间，父进程开始执行。</p></li>
<li><p>父进程在 <code class="docutils literal notranslate"><span class="pre">close(p[0])</span></code> 过程中，已经解除了 <code class="docutils literal notranslate"><span class="pre">p[0]</span></code> 对 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的映射(unmap)，还没有来得及解除对 <code class="docutils literal notranslate"><span class="pre">p[0]</span></code> 的映射。假设这时时钟中断产生，进程调度后子进程接着执行。</p></li>
<li><p>注意此时各个页的引用情况：<code class="docutils literal notranslate"><span class="pre">pageref(p[0])</span> <span class="pre">=</span> <span class="pre">2</span></code>(因为父进程还没有解除对 p[0] 的映射)，而 <code class="docutils literal notranslate"><span class="pre">pageref(p[1])</span> <span class="pre">=</span> <span class="pre">1</span></code>(因为子进程已经关闭了 p[1])。但注意，此时 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的 <code class="docutils literal notranslate"><span class="pre">pageref</span></code> 是 2，子进程中 <code class="docutils literal notranslate"><span class="pre">p[0]</span></code> 引用了 <code class="docutils literal notranslate"><span class="pre">pipe</span></code>，同时父进程中 <code class="docutils literal notranslate"><span class="pre">p[0]</span></code> 刚解除对 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的映射，所以在父进程中也只有 <code class="docutils literal notranslate"><span class="pre">p[1]</span></code> 引用了 <code class="docutils literal notranslate"><span class="pre">pipe</span></code>。</p></li>
<li><p>子进程执行 <code class="docutils literal notranslate"><span class="pre">read</span></code>，<code class="docutils literal notranslate"><span class="pre">read</span></code> 中首先判断写者是否关闭。比较 <code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span></code> 与 <code class="docutils literal notranslate"><span class="pre">pageref(p[0])</span></code> 之后发现它们都是 2，说明写端已经关闭，于是子进程退出。</p></li>
</ul>
<p>从上述场景中可以发现，由于时间中断发生在父进程 <code class="docutils literal notranslate"><span class="pre">unmap</span> <span class="pre">pipe</span></code> 和 <code class="docutils literal notranslate"><span class="pre">unmap</span> <span class="pre">fd</span></code> 之间，子进程根据 <code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span> <span class="pre">==</span> <span class="pre">pageref(p[0])</span></code> 这一等式错误判断了写端已经关闭。同时，我们也可发现，父进程 <code class="docutils literal notranslate"><span class="pre">pipe_close</span></code> 的运行逻辑是首先解除 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的映射，再解除 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 的映射。但若我们在 <code class="docutils literal notranslate"><span class="pre">pipe_close</span></code> 函数中调整 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 的顺序，即首先解除 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 的映射，再解除 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的映射，可以避免上述场景的错误情况，接下来，我们将解释调整顺序后可行的原因。<br />
<code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 函数返回正确结果的条件其实只是：</p>
<ul class="simple">
<li><p>写端关闭当且仅当 <code class="docutils literal notranslate"><span class="pre">pageref(p[0])</span> <span class="pre">==</span> <span class="pre">pageref(pipe)</span></code>;</p></li>
<li><p>读端关闭当且仅当 <code class="docutils literal notranslate"><span class="pre">pageref(p[1])</span> <span class="pre">==</span> <span class="pre">pageref(pipe)</span></code>;</p></li>
</ul>
<p>比如说第一个条件，写端关闭时，当然有 <code class="docutils literal notranslate"><span class="pre">pageref(p[0])</span> <span class="pre">==</span> <span class="pre">pageref(pipe)</span></code>。但是由于进程切换的存在，我们无法确保当 <code class="docutils literal notranslate"><span class="pre">pageref(p[0])</span> <span class="pre">==</span> <span class="pre">pageref(pipe)</span></code> 时，写端关闭。正面如果不好解决问题，我们可以考虑从其逆否命题着手，即我们要确保：当写端没有关闭的时候，<code class="docutils literal notranslate"><span class="pre">pageref(p[0])</span> <span class="pre"≯=</span> <span class="pre">pageref(pipe)</span></code>。<br />
我们考虑之前那个预想之外的情景，它出现的最关键原因在于：<code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的引用次数总比 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 要高。当管道的 <code class="docutils literal notranslate"><span class="pre">close</span></code> 进行到一半时，若先解除 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的映射，再解除 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 的映射，就会使得 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 引用次数的 -1 先于 <code class="docutils literal notranslate"><span class="pre">fd</span></code>。这就导致在两个 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 的间隙，会出现 <code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span> <span class="pre">==</span> <span class="pre">pageref(fd)</span></code> 的情况。若调换 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 在 <code class="docutils literal notranslate"><span class="pre">close</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 顺序，使得 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 引用次数的 -1 先于 <code class="docutils literal notranslate"><span class="pre">pipe</span></code>。在两个 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 的间隙，<code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span> <span class="pre">&gt;</span> <span class="pre">pageref(fd)</span></code> 仍成立，即使此时发生中断，也不会影响判断管道是否关闭的正确性。<br />
根据上面的描述我们其实已经能够得出一个结论：控制 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 与 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 的 <code class="docutils literal notranslate"><span class="pre">map/unmap</span></code> 的顺序可以解决进程竞争导致非同步写入的问题。<br />
我们通过控制修改 <code class="docutils literal notranslate"><span class="pre">pp_ref</span></code> 的前后顺序避免了非同步写入的问题，但是我们还得解决第二个问题：读取 <code class="docutils literal notranslate"><span class="pre">pp_ref</span></code> 的同步问题。<br />
同样是上面之前给出的代码，我们思考下面的情景：</p>
<ul class="simple">
<li><p>假设 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 结束后，子进程先执行。执行完 <code class="docutils literal notranslate"><span class="pre">close(p[1])</span></code> 后，执行 <code class="docutils literal notranslate"><span class="pre">read</span></code>，要从 <code class="docutils literal notranslate"><span class="pre">p[0]</span></code> 读取数据。但由于此时管道数据缓冲区为空，所以 <code class="docutils literal notranslate"><span class="pre">read</span></code> 函数要判断父进程中的写端是否关闭，进入到 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 函数，<code class="docutils literal notranslate"><span class="pre">pageref(fd)</span></code> 值为 2(父进程和子进程都打开了 p[0])，此时时钟中断产生。</p></li>
<li><p>内核切换到父进程执行，父进程 <code class="docutils literal notranslate"><span class="pre">close(p[0])</span></code>，之后向管道缓冲区写数据。要写的数据较多，假设写到一半时钟中断产生，进程调度后切换到子进程运行。</p></li>
<li><p>子进程继续运行，获取到 <code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span></code> 值为 2(父进程打开了 p[1], 子进程打开了p[0])，引用值相等，于是认为父进程的写端已经关闭，子进程退出。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">fd</span></code> 是一个父子进程共享的变量，但子进程中的 <code class="docutils literal notranslate"><span class="pre">pageref(fd)</span></code> 没有随父进程对 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 的修改而同步，这就造成了子进程读到的 <code class="docutils literal notranslate"><span class="pre">pageref(fd)</span></code> 成为了“脏数据”。为了保证读的同步性，子进程应当重新读取 <code class="docutils literal notranslate"><span class="pre">pageref(fd)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span></code>，并且要在确认两次读取之间进程没有切换后，才能返回正确的结果。为了实现这一点，我们要使用到之前一直都没用到的变量：<code class="docutils literal notranslate"><span class="pre">env_runs</span></code>。<br />
<code class="docutils literal notranslate"><span class="pre">env_runs</span></code> 记录了一个进程 <code class="docutils literal notranslate"><span class="pre">env_run</span></code> 的次数，这样我们就可以根据某个操作 <code class="docutils literal notranslate"><span class="pre">do()</span></code> 前后进程 <code class="docutils literal notranslate"><span class="pre">env_runs</span></code> 值是否相等，来判断在 <code class="docutils literal notranslate"><span class="pre">do()</span></code> 中进程是否发生了切换。<br />
根据上面的表述，修改 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 函数，使得它满足“同步读”的要求。注意 <code class="docutils literal notranslate"><span class="pre">env_runs</span></code> 变量是需要维护的。</p>
</section>
<section id="id83">
<h3><span class="section-number">7.2.4. </span>相关函数<a class="headerlink" href="#id83" title="Link to this heading"></a></h3>
<p>下面我们介绍 6 个与管道相关的函数。<br />
<strong>创建管道函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pipe(int</span> <span class="pre">pfd[2])</span></code>。<br />
这个函数的作用是创建一个管道。大致可以分为三步：</p>
<ul class="simple">
<li><p>首先，创建并分配两个文件描述符 <code class="docutils literal notranslate"><span class="pre">fd0</span></code>、<code class="docutils literal notranslate"><span class="pre">fd1</span></code>，并为这两个文件描述符自身分配相应的空间。</p></li>
<li><p>然后给 <code class="docutils literal notranslate"><span class="pre">fd0</span></code> 对应的数据区域分配一页空间，并将 <code class="docutils literal notranslate"><span class="pre">fd1</span></code> 对应的数据区域映射到相同的物理页，这一页的内容为 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 结构体。</p></li>
<li><p>最后，将作为读端的 <code class="docutils literal notranslate"><span class="pre">fd0</span></code> 的权限设置为只读，作为写端的 <code class="docutils literal notranslate"><span class="pre">fd1</span></code> 的权限设置为只写，并通过函数的传入参数将这两个文件描述符的编号返回。</p></li>
</ul>
<p>值得注意的是，目前我们一共分配了三个页面，权限位均需要包含 <code class="docutils literal notranslate"><span class="pre">PTE_LIBRARY</span></code>，这是因为这些页面的数据对于父子进程是共享的，修改页面内容时不触发写时复制，这样才能顺利的在父子进程之间传递信息。<br />
<strong>两个查询管道是否关闭的函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">_pipe_is_closed(struct</span> <span class="pre">Fd</span> <span class="pre">*fd,</span> <span class="pre">struct</span> <span class="pre">Pipe</span> <span class="pre">*p)</span></code> 与 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pipe_is_closed(int</span> <span class="pre">fdnum)</span></code>。<br />
这两个函数的作用是判断管道是否已经被关闭，其中，函数的主要逻辑存在于 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 中，<code class="docutils literal notranslate"><span class="pre">pipe_is_closed</span></code> 是对于 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 的重新封装。<br />
通过创建管道时，分配的页面以及映射关系可知，文件描述符所在页面 <code class="docutils literal notranslate"><span class="pre">rfd</span></code>、<code class="docutils literal notranslate"><span class="pre">wfd</span></code> 被读端写端各自映射一次，管道页面 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 被读端写端同时映射，被映射两次，因此则有如下等式</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pageref</span><span class="p">(</span><span class="n">rfd</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pageref</span><span class="p">(</span><span class="n">wfd</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pageref</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span><span class="w"> </span>
</pre></div>
</div>
<p>当管道某一端被关闭后，这一端映射的页面将被解除，假设当前调用此函数的进程为读进程，写端关闭，则 <code class="docutils literal notranslate"><span class="pre">pageref(wfd)</span> <span class="pre">=</span> <span class="pre">0</span></code>，当前进程为写进程时类似，因此，当管道另一端关闭时，以下等式成立：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pageref</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pageref</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span><span class="w">  </span>
</pre></div>
</div>
<p>需要注意的是，在 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 中，我们需要利用两次 <code class="docutils literal notranslate"><span class="pre">pageref</span></code> 函数分别获取 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pipe</span></code> 对应页面的引用数，由于这两次操作不是原子的，之间可能被时间片调度打断，导致 <code class="docutils literal notranslate"><span class="pre">pageref(fd)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pageref(pipe)</span></code> 非同步获取，先获取的数据失效。为了解决这个问题，我们需要确保两次获取 <code class="docutils literal notranslate"><span class="pre">pageref</span></code> 时进程没有切换，也就是两次获取 <code class="docutils literal notranslate"><span class="pre">pageref</span></code> 前后的 <code class="docutils literal notranslate"><span class="pre">env-&gt;env_run</span></code> 变量没有变化时，再根据等式判断管道另一端是否被关闭。若等式成立，则说明管道另一端已经关闭，返回 1,否则返回 0。<br />
<strong>读管道函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">pipe_read(struct</span> <span class="pre">Fd</span> <span class="pre">*fd,</span> <span class="pre">void</span> <span class="pre">*vbuf,</span> <span class="pre">u_int</span> <span class="pre">n,u_int</span> <span class="pre">offset)</span></code>。<br />
这个函数的作用是从 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 对应的管道数据缓冲区中，读取至多 <code class="docutils literal notranslate"><span class="pre">n</span></code> 字节到 <code class="docutils literal notranslate"><span class="pre">vbuf</span></code> 对应的虚拟地址中，并返回本次读到的字节数。<br />
读取的过程中会遇到两类可能的情况：</p>
<ul class="simple">
<li><p>缓冲区不为空：则按顺序读取缓冲区中的内容，直到缓冲区为空或达到读取上限，并返回读到的字节数。</p></li>
<li><p>缓冲区为空：则使用 <code class="docutils literal notranslate"><span class="pre">_pipe_is_closed</span></code> 函数查询管道的写端是否已经关闭，若已经关闭，则说明读入完成，函数返回0；若没有关闭，则使用 <code class="docutils literal notranslate"><span class="pre">syscall_yield()</span></code> 进行等待，直到管道关闭或缓冲区不为空。</p></li>
</ul>
<p><strong>写管道函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">pipe_write(struct</span> <span class="pre">Fd</span> <span class="pre">*fd,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*vbuf,</span> <span class="pre">u_intn,</span> <span class="pre">u_int</span> <span class="pre">offset)</span></code>。<br />
与读管道函数类似，这个函数的作用是从 <code class="docutils literal notranslate"><span class="pre">vbuf</span></code> 对应的虚拟地址，向 <code class="docutils literal notranslate"><span class="pre">fd</span></code> 对应的管道数据缓冲区中写入 <code class="docutils literal notranslate"><span class="pre">n</span></code> 字节，并返回本次写入的字节数。<br />
此处的参数 <code class="docutils literal notranslate"><span class="pre">n</span></code> 与读取时有所不同，表示需要写入恰好 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个字节，而非缓冲区的长度上限。因此，在完成全部 <code class="docutils literal notranslate"><span class="pre">n</span></code> 个字节的写入之前，若管道缓冲区已满，则需要使用 <code class="docutils literal notranslate"><span class="pre">syscall_yield()</span></code> 进行等待，而非提前返回，直到缓冲区不满或管道关闭。<br />
<strong>关闭管道函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/pipe.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">pipe_close(struct</span> <span class="pre">Fd</span> <span class="pre">*fd)</span></code>。<br />
这个函数的作用是关闭管道的一端。将待关闭的一端对应的文件描述符传入，并 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 文件描述符自身的页面以及 <code class="docutils literal notranslate"><span class="pre">unmap</span></code> 文件描述符对应的数据页面—<code class="docutils literal notranslate"><span class="pre">pipe</span></code>结构体，完成关闭操作。</p>
</section>
</section>
<section id="id84">
<h2><span class="section-number">7.3. </span>shell<a class="headerlink" href="#id84" title="Link to this heading"></a></h2>
<p>在计算机科学中，<code class="docutils literal notranslate"><span class="pre">shell</span></code> 是指“为使用者提供操作界面”的软件（命令解析器）。它接收用户命令，然后调用相应的应用程序。基本上 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 分两大类：<br />
一是图形界面 <code class="docutils literal notranslate"><span class="pre">shell（Graphical</span> <span class="pre">User</span> <span class="pre">Interface</span> <span class="pre">shell</span> <span class="pre">即</span> <span class="pre">GUI</span> <span class="pre">shell）</span></code>。例如：应用最为广泛的是微软 <code class="docutils literal notranslate"><span class="pre">Windows</span></code> 系列操作系统的 <code class="docutils literal notranslate"><span class="pre">Windows</span> <span class="pre">Explorer</span></code>，也包括广为人知的 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 操作系统的<code class="docutils literal notranslate"><span class="pre">XWindow</span> <span class="pre">Manager（BlackBox</span> <span class="pre">和</span> <span class="pre">FluxBox）</span></code>，以及功能更强大的 <code class="docutils literal notranslate"><span class="pre">CDE</span></code>、<code class="docutils literal notranslate"><span class="pre">GNOME</span></code>、<code class="docutils literal notranslate"><span class="pre">KDE</span></code> 和 <code class="docutils literal notranslate"><span class="pre">XFCE</span></code> 等。<br />
二是命令行式 <code class="docutils literal notranslate"><span class="pre">shell（Command</span> <span class="pre">Line</span> <span class="pre">Interface</span> <span class="pre">shell</span> <span class="pre">，即</span> <span class="pre">CLI</span> <span class="pre">shell）</span></code>，也就是我们 <code class="docutils literal notranslate"><span class="pre">la64</span></code> 操作系统最后即将实现的 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 模式。</p>
<section id="spawn">
<h3><span class="section-number">7.3.1. </span>学习 spawn 函数<a class="headerlink" href="#spawn" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spawn</span></code> 的作用是帮助我们调用文件系统中的可执行文件并执行。<br />
<code class="docutils literal notranslate"><span class="pre">spawn</span></code> 的流程可以分解如下：</p>
<ul class="simple">
<li><p>从文件系统打开对应的文件（二进制 ELF，在我们的OS里是 *.b）；</p></li>
<li><p>申请新的进程控制块；</p></li>
<li><p>将目标程序加载到子进程的地址空间中，并为它们分配物理页面；</p></li>
<li><p>为子进程初始化地址空间。对于栈空间，由于 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 需要将命令行参数传递给用户程序，所以要将参数也写入用户栈中；</p></li>
<li><p>设置子进程的寄存器（栈指针 sp 和用户程序入口 EPC）；</p></li>
<li><p>将父进程的共享页面映射到子进程的地址空间中；</p></li>
<li><p>这些都做完后，设置子进程可执行。</p></li>
</ul>
<p>关于如何为子进程初始化栈空间，请仔细阅读 <code class="docutils literal notranslate"><span class="pre">init_stack</span></code> 函数。<br />
因为我们无法直接操作子进程的栈空间，所以该函数首先将需要准备的参数填充到本进程的 <code class="docutils literal notranslate"><span class="pre">UTEMP</span></code> 这个页面处，然后将 <code class="docutils literal notranslate"><span class="pre">UTEMP</span></code> 映射到子进程的栈空间中。<br />
首先将 <code class="docutils literal notranslate"><span class="pre">argc</span></code> 个字符串填到栈上，并且不要忘记在每个字符串的末尾要加上 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>表示结束，然后将 <code class="docutils literal notranslate"><span class="pre">argc</span> <span class="pre">+</span> <span class="pre">1</span></code> 个指针填到栈上，第 <code class="docutils literal notranslate"><span class="pre">argc</span> <span class="pre">+</span> <span class="pre">1</span></code> 个指针指的是一个空字符串表示参数的结束。<br />
最后将 <code class="docutils literal notranslate"><span class="pre">argc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">argv</span></code> 填到栈上，<code class="docutils literal notranslate"><span class="pre">argv</span></code> 将指向那 <code class="docutils literal notranslate"><span class="pre">argc</span> <span class="pre">+</span> <span class="pre">1</span></code> 个字符指针。<br />
这里给出一张 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 准备的栈空间的示意图。</p>
<img alt="子进程栈空间示意图" class="bg-primary align-center" src="_images/%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" />
</section>
<section id="id85">
<h3><span class="section-number">7.3.2. </span>解释 shell 命令<a class="headerlink" href="#id85" title="Link to this heading"></a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">Lab5</span></code> 中我们实现了文件系统，<code class="docutils literal notranslate"><span class="pre">Lab6</span></code> 中我们在 <code class="docutils literal notranslate"><span class="pre">user</span></code> 目录下提供了 <code class="docutils literal notranslate"><span class="pre">ls.c</span></code>、<code class="docutils literal notranslate"><span class="pre">cat.c</span></code>、<code class="docutils literal notranslate"><span class="pre">echo.c</span></code>等几个用户程序，模拟了 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 下的同名命令，而 <code class="docutils literal notranslate"><span class="pre">Shell</span></code> 程序 <code class="docutils literal notranslate"><span class="pre">sh.c</span></code> 调用了上面提到的 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 函数，其能够读取相应的可执行文件，并加载到新进程中运行。请阅读 <code class="docutils literal notranslate"><span class="pre">fs/Makefile</span></code>，思考我们是如何将这些用户程序编译得到的可执行文件“烧录”到 <code class="docutils literal notranslate"><span class="pre">la64</span></code> 的文件系统中的。<br />
接下来，我们需要在 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 进程里实现对管道和重定向的解释功能。解释 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 命令时：</p>
<ol class="arabic simple">
<li><p>如果碰到重定向符号 ‘&lt;’ 或者 ‘&gt;’,则读下一个单词，打开这个单词所代表的文件，然后将其复制给标准输入或者标准输出。</p></li>
<li><p>如果碰到管道符号 ‘|’,则首先需要建立管道 <code class="docutils literal notranslate"><span class="pre">pipe</span></code>，然后 <code class="docutils literal notranslate"><span class="pre">fork</span></code>。</p>
<ul class="simple">
<li><p>对于父进程，需要将管道的写者复制给标准输出，然后关闭父进程的读者和写者，运行 ‘|’ 左边的命令，获得输出，然后等待子进程运行。</p></li>
<li><p>对于子进程，将管道的读者复制给标准输入，从管道中读取数据，然后关闭子进程的读者和写者，继续读下一个单词。</p></li>
</ul>
</li>
</ol>
<p>在这里可以举一个使用管道符号的例子来方便大家理解，我们学习过的 <code class="docutils literal notranslate"><span class="pre">Linux</span></code> 中的管道命令 <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">my.sh</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">&quot;Hello&quot;</span></code> 这就是使用管道的例子，<code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">my.sh</span></code> 命令会将 <code class="docutils literal notranslate"><span class="pre">my.sh</span></code> 中的内容原文写入到管道，而 <code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">&quot;Hello&quot;</span></code> 命令作为子进程执行，将管道中的内容读出并作为 <code class="docutils literal notranslate"><span class="pre">grep</span></code> 的输入，进行查找字符串操作并将查找结果输出到标准输出。<br />
在 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 函数中通过设置 <code class="docutils literal notranslate"><span class="pre">PTE_LIBRARY</span></code> 权限位，将父进程所有的共享页面映射给了子进程。<br />
想一下，进程空间中的哪些内存是共享内存？<br />
在进程空间中，文件、管道、控制台以及文件描述符都是以共享页面的方式存在的。有几处通过 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 产生新进程的位置。</p>
<ul class="simple">
<li><p>如下图所示，内核启动的进程 <code class="docutils literal notranslate"><span class="pre">user/icode.b</span></code> 调用了 <code class="docutils literal notranslate"><span class="pre">spawn</span></code>，创建了 <code class="docutils literal notranslate"><span class="pre">init.b</span></code> 进程。<code class="docutils literal notranslate"><span class="pre">init.b</span></code> 进程先打开控制台（console）作为 0 和 1 号文件描述符（fd），也就是进程的标准输入和输出，然后调用 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 创建了 <code class="docutils literal notranslate"><span class="pre">sh.b</span></code> 进程，也就是我们的 <code class="docutils literal notranslate"><span class="pre">shell</span></code>。通过共享页面（PTE_LIBRARY）机制，<code class="docutils literal notranslate"><span class="pre">fork</span></code> 和 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 创建的子进程继承了父进程持有的 <code class="docutils literal notranslate"><span class="pre">fd</span></code>，所以 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 进程仍能通过标准输入输出操作控制台，与用户进行交互。</p></li>
</ul>
<img alt="shell启动执行过程" class="bg-primary align-center" src="_images/shell%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" />
<ul class="simple">
<li><p>子 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 进程负责解析命令行命令，并通过 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 生成可执行程序进程（对应*.b文件）。在解析命令行的命令时，子 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 会将重定向的文件及管道等 <code class="docutils literal notranslate"><span class="pre">dup</span></code> 到子 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 的标准输入或输出，然后 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 时将标准输入和输出通过共享内存映射给可执行程序，所以可执行程序可以从控制台、文件和管道等位置输入和输出数据。</p></li>
</ul>
</section>
<section id="id86">
<h3><span class="section-number">7.3.3. </span>相关函数<a class="headerlink" href="#id86" title="Link to this heading"></a></h3>
<p>下面我们介绍 8 个与 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 相关的函数。<br />
<strong>初始化栈空间函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/spawn.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">init_stack(u_int</span> <span class="pre">child,</span> <span class="pre">char</span> <span class="pre">**argv,</span> <span class="pre">u_int</span> <span class="pre">*init_esp)</span></code>。<br />
这个函数的作用是初始化子进程的栈空间，达到向子进程的主函数传递参数的目的。由于父进程无法直接操作子进程的栈空间，因此需要将参数填充到当前进程的 <code class="docutils literal notranslate"><span class="pre">TMPPAGE</span></code> 页面处，将 <code class="docutils literal notranslate"><span class="pre">TMPPAGE</span></code> 映射到子进程的栈空间中。具体参数填充方式可以参考之前所给图。<br />
<strong>spawn 函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/lib/spawn.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">spawn(char</span> <span class="pre">*prog,</span> <span class="pre">char</span> <span class="pre">**argv)</span></code>。<br />
这个函数与 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 函数类似，其最终效果都是产生一个子进程，不过与 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 函数不同的是，<code class="docutils literal notranslate"><span class="pre">spawn</span></code> 函数产生的子进程不再执行与父进程相同的程序，而是装载新的 <code class="docutils literal notranslate"><span class="pre">ELF</span></code> 文件，执行新的程序。<br />
spawn 函数的大致流程如下：</p>
<ol class="arabic simple">
<li><p>使用文件系统提供的 <code class="docutils literal notranslate"><span class="pre">open</span></code> 函数打开即将装载的 <code class="docutils literal notranslate"><span class="pre">ELF</span></code> 文件 <code class="docutils literal notranslate"><span class="pre">prog</span></code>。</p></li>
<li><p>使用系统调用 <code class="docutils literal notranslate"><span class="pre">syscall_exofork</span></code> 函数为子进程申请一个进程控制块。</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">init_stack</span></code> 函数为子进程初始化栈空间，将需要传递的参数 <code class="docutils literal notranslate"><span class="pre">argv</span></code> 传入子进程。</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">elf_load_seg</span></code> 将 <code class="docutils literal notranslate"><span class="pre">ELF</span></code> 文件的各个段加载进子进程。</p></li>
<li><p>设置子进程的运行现场寄存器，将 <code class="docutils literal notranslate"><span class="pre">tf-&gt;era</span></code> 设置为程序入口点，<code class="docutils literal notranslate"><span class="pre">tf-&gt;regs[29]</span></code> 设置为装载参数后的栈顶指针，从而在子进程被唤醒时以正确的状态开始运行。</p></li>
<li><p>将父进程的共享页面映射给子进程，与 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 不同的是，这里只映射共享页面。</p></li>
<li><p>使用系统调用 <code class="docutils literal notranslate"><span class="pre">syscall_set_env_status</span></code> 唤醒子进程。</p></li>
</ol>
<p>其中，第1步、第3步和第4步是相比 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 函数新增的部分，第5步和第6步与 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 略有不同，第2步和第7步与 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 中的步骤几乎一致。<br />
<strong>sh.c 中的主函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/sh.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">main(int</span> <span class="pre">argc,</span> <span class="pre">char</span> <span class="pre">**argv)</span></code>。<br />
与 <code class="docutils literal notranslate"><span class="pre">pipe.c</span></code> 这样的用户库不同，<code class="docutils literal notranslate"><span class="pre">sh.c</span></code> 是一个完整的用户程序，也就是 <code class="docutils literal notranslate"><span class="pre">shell</span></code>，其主函数即为启动 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 进程时第一步进入的函数。函数的主体是一个死循环，循环中大致流程如下：</p>
<ul class="simple">
<li><p>调用 <code class="docutils literal notranslate"><span class="pre">readline</span></code> 读入用户输入的命令。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fork</span></code> 出一个子进程。</p></li>
<li><p>子进程执行用户的命令，执行结束后子进程结束。父进程在此等待子进程。</p></li>
<li><p>父进程等待子进程结束后，返回循环开始，读入用户的下一个命令。</p></li>
</ul>
<p><strong>命令读入函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/sh.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">readline(char</span> <span class="pre">*buf,</span> <span class="pre">u_int</span> <span class="pre">n)</span></code>。<br />
这个函数的作用是从标准输入（控制台），读入一行用户读入的命令，保存在 <code class="docutils literal notranslate"><span class="pre">char*</span> <span class="pre">buf</span></code> 中。<br />
<strong>命令解析函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/sh.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">_gettoken(char</span> <span class="pre">*s,</span> <span class="pre">char</span> <span class="pre">**p1,</span> <span class="pre">char</span> <span class="pre">**p2)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">gettoken(char*s,</span> <span class="pre">char</span> <span class="pre">**p1)</span></code>。<br />
<code class="docutils literal notranslate"><span class="pre">gettoken</span></code> 函数接收 <code class="docutils literal notranslate"><span class="pre">readline</span></code> 读入的命令字符串作为传入参数 <code class="docutils literal notranslate"><span class="pre">char*</span> <span class="pre">s</span></code>。这个两个函数的作用是将命令字符串分割，提取命令中基本单元——特殊符号或单词，并过滤空白字符。其中，<code class="docutils literal notranslate"><span class="pre">gettoken</span></code> 是对于 <code class="docutils literal notranslate"><span class="pre">_gettoken</span></code> 的封装，调用 <code class="docutils literal notranslate"><span class="pre">gettoken</span></code> 时，每次调用返回上一次调用解析到的基本单元，并解析下一个基本单元。<br />
特殊符号包括重定向符号 &lt; 和 &gt;、管道符号 |、命令分隔符号 ; 和 &amp; 。<br />
<strong>cmd 命令解析与执行函数</strong><br />
<code class="docutils literal notranslate"><span class="pre">user/sh.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">parsecmd(char</span> <span class="pre">**argv,</span> <span class="pre">int</span> <span class="pre">*rightpipe)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">user/sh.c</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">runcmd(char</span> <span class="pre">*s)</span></code>。<br />
<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">parsecmd(char</span> <span class="pre">**argv,</span> <span class="pre">int</span> <span class="pre">*rightpipe)</span></code> 这个函数的作用是解析用户输入的命令。通过调用 <code class="docutils literal notranslate"><span class="pre">gettoken</span></code>，将命令解析成单个词法单元，保存在 <code class="docutils literal notranslate"><span class="pre">argv</span></code> 中，并在遇到重定向、管道等特殊符号时做相应的特殊处理。当解析完一条命令包含的所有词法单元后，结束 <code class="docutils literal notranslate"><span class="pre">parsecmd</span></code> 函数，进入 <code class="docutils literal notranslate"><span class="pre">runcmd</span></code> 函数的命令执行阶段。特别地，当命令中包含管道操作时，则需要创建管道并 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 出一个子 <code class="docutils literal notranslate"><span class="pre">shell</span></code>。子进程调用 <code class="docutils literal notranslate"><span class="pre">parsecmd</span></code> 函数继续解析管道右侧的命令，父进程返回 <code class="docutils literal notranslate"><span class="pre">runcmd</span></code> 函数执行管道左侧命令，此时 <code class="docutils literal notranslate"><span class="pre">rightpipe</span></code> 记录子进程的进程号也就是解析并执行管道右侧命令的进程号，用于管道左侧命令进程等待管道右侧命令进程执行完毕后再释放。<br />
<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">runcmd(char</span> <span class="pre">*s)</span></code> 这个函数的作用是执行解析出的每一条命令。通过 <code class="docutils literal notranslate"><span class="pre">argv</span></code> 判断命令的种类，调用 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 产生子进程并装载命令对应的 <code class="docutils literal notranslate"><span class="pre">ELF</span></code> 文件，子进程执行命令，父进程在此处等待子进程结束后，结束进程。随后，上文提到的在 <code class="docutils literal notranslate"><span class="pre">main</span></code> 循环结尾处等待的进程，也就是此处父进程的父进程，结束等待，返回循环开始，读入新一行命令。具体进程间的层次关系可以参照下图。<br />
<strong>shell 相关函数调用关系</strong></p>
<img alt="shell相关函数调用关系" class="bg-primary align-center" src="_images/shell%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png" />
</section>
</section>
<section id="id87">
<h2><span class="section-number">7.4. </span>实验正确结果<a class="headerlink" href="#id87" title="Link to this heading"></a></h2>
<p>本节将通过一些测试用例评测管道和 <code class="docutils literal notranslate"><span class="pre">Shell</span></code> 的正确性，同时给出了测试结果的截图，同学们可以自行核对。</p>
<section id="id88">
<h3><span class="section-number">7.4.1. </span>管道测试<a class="headerlink" href="#id88" title="Link to this heading"></a></h3>
<p>管道测试对应的测试点为 <code class="docutils literal notranslate"><span class="pre">tests/lab6_1</span></code>，测试中有三个文件，分别是 <code class="docutils literal notranslate"><span class="pre">user/testpipe.c</span></code>、<code class="docutils literal notranslate"><span class="pre">user/testpiperace.c</span></code> 和 <code class="docutils literal notranslate"><span class="pre">user/testelibrary.c</span></code>，以合适的次序建好进程后，在 <code class="docutils literal notranslate"><span class="pre">testpipe</span></code> 的测试中若出现两次 <code class="docutils literal notranslate"><span class="pre">pipe</span> <span class="pre">tests</span> <span class="pre">passed</span></code> 即说明测试通过。<br />
testpipe 本地测试部分运行结果如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">00001802</span><span class="p">]</span> <span class="n">pipecreate</span>
<span class="o">.................................</span>
<span class="n">pipe</span> <span class="n">write</span> <span class="n">closed</span> <span class="n">properly</span>
<span class="n">pipe</span> <span class="n">tests</span> <span class="n">passed</span>
<span class="p">[</span><span class="mi">00004005</span><span class="p">]</span> <span class="n">destroying</span> <span class="mi">00004005</span>
<span class="p">[</span><span class="mi">00004005</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00004005</span>
<span class="n">i</span> <span class="n">am</span> <span class="n">killed</span> <span class="o">...</span>
<span class="n">pipe</span> <span class="n">tests</span> <span class="n">passed</span>
<span class="p">[</span><span class="mi">00001802</span><span class="p">]</span> <span class="n">destroying</span> <span class="mi">00001802</span>
<span class="p">[</span><span class="mi">00001802</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00001802</span>
<span class="n">i</span> <span class="n">am</span> <span class="n">killed</span> <span class="o">...</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">testpiperace</span></code> 中，子进程多次查询管道是否关闭。而父进程不停地执行 <code class="docutils literal notranslate"><span class="pre">dup</span></code> 函数，<code class="docutils literal notranslate"><span class="pre">dup</span></code> 操作主要包含两个操作，分别是关闭映射目标原有的管道（close ）和将旧文件映射到新文件（包括文件描述符和文件内容）。如果这两个操作中有任意一个操作产生竞争，将可能导致子进程认为写入端关闭。<br />
在 <code class="docutils literal notranslate"><span class="pre">testpiperace</span></code> 的测试中应当出现 <code class="docutils literal notranslate"><span class="pre">race</span> <span class="pre">didn’t</span> <span class="pre">happen</span></code> 是正确的。<code class="docutils literal notranslate"><span class="pre">testpiperace</span></code> 本地测试部分运行结果如下。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">race</span> <span class="n">didn</span><span class="s1">&#39;t happen</span>
<span class="p">[</span><span class="mi">00002003</span><span class="p">]</span> <span class="n">destroying</span> <span class="mi">00002003</span>
<span class="p">[</span><span class="mi">00002003</span><span class="p">]</span> <span class="n">free</span> <span class="n">env</span> <span class="mi">00002003</span>
<span class="n">i</span> <span class="n">am</span> <span class="n">killed</span> <span class="o">...</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">user/testptelibrary.c</span></code> 的测试中，如果 <code class="docutils literal notranslate"><span class="pre">fork</span></code> 和 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 对于共享页面的处理正确，测试才能通过。</p>
</section>
<section id="id89">
<h3><span class="section-number">7.4.2. </span>shell 测试<a class="headerlink" href="#id89" title="Link to this heading"></a></h3>
<p>在 <code class="docutils literal notranslate"><span class="pre">init/init.c</span></code> 中按照如下顺序依次启动 <code class="docutils literal notranslate"><span class="pre">shell</span></code> 和文件服务：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">	</span><span class="n">ENV_CREATE</span><span class="p">(</span><span class="n">user_icode</span><span class="p">);</span>
<span class="w">	</span><span class="n">ENV_CREATE</span><span class="p">(</span><span class="n">fs_serv</span><span class="p">);</span>
</pre></div>
</div>
<p>如果正常会看到如下效果。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span>
<span class="p">::</span>                                                            <span class="p">::</span>
<span class="p">::</span>                    <span class="n">MOS</span> <span class="n">Shell</span> <span class="mi">2023</span>               <span class="p">::</span> 
<span class="p">::</span>                                                            <span class="p">::</span>
<span class="p">:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span>
</pre></div>
</div>
<p>使用不同的命令会有不同的效果：</p>
<ul class="simple">
<li><p>执行 <code class="docutils literal notranslate"><span class="pre">ls.b</span></code>，会显示一些文件和目录名。</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>ls.b
testarg.b<span class="w"> </span>cat.b<span class="w"> </span>pingpong.b<span class="w"> </span>testbss.b<span class="w"> </span>newmotd<span class="w"> </span>testpiperace.b<span class="w"> </span>testpipe.b
motd<span class="w"> </span>init.b<span class="w"> </span>num.b<span class="w"> </span>testfdsharing.b<span class="w"> </span>ls.b<span class="w"> </span>echo.b<span class="w"> </span>sh.b<span class="w"> </span>halt.b<span class="w"> </span>testptelibrary.b
</pre></div>
</div>
<ul class="simple">
<li><p>执行 <code class="docutils literal notranslate"><span class="pre">cat.b</span></code> 并输入任意字符，会有回显现象出现，按下 <code class="docutils literal notranslate"><span class="pre">Ctrl-D</span></code> 可结束输入。</p></li>
<li><p>执行 <code class="docutils literal notranslate"><span class="pre">cat.b</span> <span class="pre">motd</span></code>，会显示文件 <code class="docutils literal notranslate"><span class="pre">motd</span></code> 中的内容。</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cat.b
aabbcc
</pre></div>
</div>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cat.b<span class="w"> </span>motd
This<span class="w"> </span>is<span class="w"> </span>/motd,<span class="w"> </span>the<span class="w"> </span>message<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>day.

Welcome<span class="w"> </span>to<span class="w"> </span>the<span class="w"> </span>MOS<span class="w"> </span>kernel,<span class="w"> </span>now<span class="w"> </span>with<span class="w"> </span>a<span class="w"> </span>file<span class="w"> </span>system!
</pre></div>
</div>
<ul class="simple">
<li><p>执行 <code class="docutils literal notranslate"><span class="pre">ls.b</span> <span class="pre">|</span> <span class="pre">cat.b</span></code>，和 <code class="docutils literal notranslate"><span class="pre">ls.b</span></code> 的现象应当一致。</p></li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>ls.b<span class="w"> </span><span class="p">|</span><span class="w"> </span>cat.b
testarg.b<span class="w"> </span>cat.b<span class="w"> </span>pingpong.b<span class="w"> </span>testbss.b<span class="w"> </span>newmotd<span class="w"> </span>testpiperace.b<span class="w"> </span>testpipe.b
motd<span class="w"> </span>init.b<span class="w"> </span>num.b<span class="w"> </span>testfdsharing.b<span class="w"> </span>ls.b<span class="w"> </span>echo.b<span class="w"> </span>sh.b<span class="w"> </span>halt.b<span class="w"> </span>testptelibrary.b
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
    <a href="index.html" class="btn btn-neutral float-left" title="目录" accesskey="p"
      rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
  </div>

  <hr />

  <div role="contentinfo">
    <p>&#169; 版权所有 龙芯实验室.
      <span class="lastupdated">最后更新于 2026年1月28日 11:21:44.
      </span>

      <!-- 
      <span class="footer-aside">
        <a href="./基于loongarch64的一个小型操作系统实验（改编自北航mos操作系统）.pdf" class="fa fa-file-pdf-o">&nbsp下载 PDF</a>
      </span>
       -->
    </p>
  </div> 

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>